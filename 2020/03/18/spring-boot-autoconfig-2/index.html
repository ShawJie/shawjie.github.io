<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="Hexo Theme Keep"><meta name="author" content="ShawJie"><title>Spring Boot 自动装配原理 / 2 | Shaw&#39;s Log | 茶歇小栈</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/base_icon.ico"><link rel="stylesheet" href="/font/css/fontawesome.min.css"><link rel="stylesheet" href="/font/css/regular.min.css"><link rel="stylesheet" href="/font/css/solid.min.css"><link rel="stylesheet" href="/font/css/brands.min.css"><script class="keep-theme-configurations">const KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"shawjie.cn",root:"/",language:"en"},KEEP.theme_config={base_info:{primary_color:"#26de81",avatar:"/images/dear_kana.jpg",logo:"/images/dear_kana.jpg",favicon:"/images/base_icon.ico"},menu:{Archives:"/archives",Tags:"/tags",About:"/about"},first_screen:{enable:!0,background_img:"/images/bg.svg",background_img_dark:"/images/bg.svg",description:"愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。||能做事的做事，能发声的发声",hitokoto:!1},social_contact:{enable:!1,links:{github:null,weixin:null,qq:null,weibo:null,zhihu:null,twitter:null,facebook:null,email:null}},scroll:{progress_bar:!1,percent:!0,hide_header:!0},home:{category:!0,tag:!0,announcement:null},post:{author_badge:{enable:!1,level_badge:!0,custom_badge:["One","Two","Three"]},word_count:{wordcount:!0,min2read:!0},datetime_format:"YYYY-MM-DD HH:mm:ss",copyright_info:!1,share:!1,reward:{enable:!1,img_link:null,text:null}},code_block:{tools:{enable:!0,style:"mac"},highlight_theme:"obsidian"},toc:{enable:!0,number:!1,expand_all:!0,init_open:!0,layout:"right"},website_count:{busuanzi_count:{enable:!1,site_uv:!0,site_pv:!0,page_pv:!0}},local_search:{enable:!0,preload:!0},comment:{enable:!1,use:"valine",valine:{appid:null,appkey:null,server_urls:null,placeholder:null},gitalk:{github_id:null,github_admins:null,repository:null,client_id:null,client_secret:null,proxy:null},twikoo:{env_id:null,region:null,version:"1.6.21"},waline:{server_url:null,reaction:!1,version:2},giscus:{repo:null,repo_id:null,category:"Announcements",category_id:null,reactions_enabled:!1},artalk:{server:null},disqus:{shortname:null}},rss:{enable:!1},lazyload:{enable:!0},cdn:{enable:!1,provider:"jsdelivr"},pjax:{enable:!0},footer:{since:2019,word_count:!1,icp:{enable:!0,record_code:"浙ICP备20000303号-1",url:"https://beian.miit.gov.cn"},site_deploy:{enable:!1,provider:"github",url:null},shields_style:{enable:!1,custom:[{link_url:null,img_url:null}]}},inject:{enable:!0,css:[null],js:["/js/custom_home.js"]},root:"",version:"4.0.2"},KEEP.language_ago={second:"%s seconds ago",minute:"%s minutes ago",hour:"%s hours ago",day:"%s days ago",week:"%s weeks ago",month:"%s months ago",year:"%s years ago"},KEEP.language_code_block={copy:"Copy code",copied:"Copied",fold:"Fold code block",folded:"Folded"},KEEP.language_copy_copyright={copy:"Copy copyright info",copied:"Copied",title:"Original article title",author:"Original article author",link:"Original article link"}</script><meta name="generator" content="Hexo 7.0.0"></head><body><div class="progress-bar-container"><span class="pjax-progress-bar"></span> <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i></div><main class="page-container border-box"><div class="page-main-content border-box"><div class="page-main-content-top"><header class="header-wrapper"><div class="border-box header-content"><div class="left border-box"><a class="logo-image border-box" href="/"><img src="/images/dear_kana.jpg"> </a><a class="site-name border-box" href="/">Shaw&#39;s Log | 茶歇小栈</a></div><div class="right border-box"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">HOME</a></li><li class="menu-item"><a href="/archives">ARCHIVES</a></li><li class="menu-item"><a href="/tags">TAGS</a></li><li class="menu-item"><a href="/about">ABOUT</a></li><li class="menu-item search search-popup-trigger"><i class="fas search fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">HOME</a></li><li class="drawer-menu-item flex-center"><a href="/archives">ARCHIVES</a></li><li class="drawer-menu-item flex-center"><a href="/tags">TAGS</a></li><li class="drawer-menu-item flex-center"><a href="/about">ABOUT</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle border-box"><div class="main-content border-box"><div class="fade-in-down-animation"><div class="post-page-container border-box"><div class="article-content-container border-box"><div class="article-content-top border-box" style="height:13.8rem"><div class="cover-article-title">Spring Boot 自动装配原理 / 2</div><img class="post-cover" src="/images/spring-boot-autoconfig-2/TwkBv5ZjhRDCtny.png" onerror='this.style.display="none"'></div><div class="article-content-bottom border-box has-cover"><div class="article-header border-box"><div class="avatar-box border-box"><img src="/images/dear_kana.jpg"></div><div class="info-box"><div class="author"><span class="name">ShawJie</span></div><div class="meta-info border-box"><div class="article-meta-info-container border-box post"><div class="article-meta-info border-box"><span class="meta-info-item article-create-date"><i class="icon fa-solid fa-calendar-check"></i>&nbsp; <span class="pc">2020-03-18 00:08:43</span> <span class="mobile">2020-03-18 00:08</span> </span><span class="meta-info-item article-update-date"><i class="icon fa-solid fa-file-pen"></i>&nbsp; <span class="pc" data-updated="Thu Nov 30 2023 10:02:18 GMT+0800">2023-11-30 10:02:18</span> </span><span class="article-tag meta-info-item border-box"><i class="icon fas fa-tags"></i>&nbsp;<ul class="article-tag-ul"><li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/Spring-Framework/">Spring Framework</a></li><li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/Spring-Boot/">Spring Boot</a></li></ul></span></div></div></div></div></div><div class="article-content keep-markdown-body"><h1 id="Spring-Boot-自动装配原理-2"><a href="#Spring-Boot-自动装配原理-2" class="headerlink" title="Spring Boot 自动装配原理 &#x2F; 2"></a>Spring Boot 自动装配原理 &#x2F; 2</h1><blockquote><p>在上一篇内容中，我们简述了关于Spring Boot应用的几个核心注解，核心注解的元注解，以及Spring Boot应用的粗粒度启动过程，还没有看的同学可以去看一看，链接在<a class="link" target="_blank" rel="noopener" href="https://shawjie.me/2020/03/12/Spring_Boot_AutoConfig_1/">这里<i class="fas fa-external-link-alt"></i></a>。这一节我们会对自动装配属性的解析，到自动装配的过程进行一个详细的分析论述，本篇源码会比较多，也希望大家耐心阅读。</p></blockquote><h2 id="主类是如何被加载注册的"><a href="#主类是如何被加载注册的" class="headerlink" title="主类是如何被加载注册的"></a>主类是如何被加载注册的</h2><p>​	通过第一篇内容我们可以知道，自动装配注解<code>@EnableAutoConfiguration</code>是<code>@SpringBootApplication</code>的元注解，而<code>@SpringBootApplication</code>又注解于我们的应用启动类上，那么我们的应用启动类（即主类）是如何被加载进Spring的容器中的呢？</p><p>​	Spring Boot应用通过<code>SpringApplication.run(primarySource, args)</code>方法进行启动，而参数<code>primarySource</code>需要传入的是应用加载的主要来源，即我们主类的类定义。从<a class="link" target="_blank" rel="noopener" href="https://start.spring.io/">Spring initializer<i class="fas fa-external-link-alt"></i></a>构建的Demo我们可以看到，<code>primarySource</code>的传入值是<code>DemoApplication.class</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	在Spring Boot应用初始化阶段（上篇有提到，没看过的去看一下，明确一下概念），run方法会构建一个<code>SpirngApplication</code>对象实例，并将我们传入的主类定义保存在对象实例的<code>primarySources</code>字段中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.primarySources = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">    <span class="built_in">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">    <span class="built_in">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	这个字段有什么用我们过会再说，现在先让我们记下<code>SpringApplication</code>对象实例的<code>primarySources</code>储存了我们的启动类定义。</p><h3 id="加载的META-INF-spring-factories"><a href="#加载的META-INF-spring-factories" class="headerlink" title="加载的META-INF&#x2F;spring.factories"></a>加载的META-INF&#x2F;spring.factories</h3><p>​	我们先顺着往下看<code>deduceFromClasspath()</code>方法，该方法用于推断我们的Spring应用类型（Servlet、Reactive、None），而推断的方法则是通过类加载器对几种Spring应用类型的核心类进行加载，返回true则表示加载成功，反之抛出异常则表示加载失败，类路径中不存在该类。这种推断方式很聪明，在之后的自动装配部分也会有类似的逻辑。再之后是<code>setInitializers()</code>方法，这个方法会设置<code>ApplicationContextInitializer</code>到<code>SpringApplication</code>实例，这不是我们的重点，我们的重点在于它的嵌套方法<code>getSpringFactoriesInstances(type)</code>，也是我在上篇内容标记的第一个重点。</p><p>​	&#96;&#96;getSpringFactoriesInstances()&#96;的内部逻辑如下，具体的操作我用注释标在了代码上面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取类加载器</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> getClassLoader();</span><br><span class="line">    <span class="comment">// 从META-INF/spring.factories获取type对应类的全限定名以确保唯一性</span></span><br><span class="line">    Set&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">    <span class="comment">// 通过反射构建对象实例</span></span><br><span class="line">    List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</span><br><span class="line">    <span class="comment">// 根据注解@Order对实例进行排序</span></span><br><span class="line">    AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">    <span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	进入<code>SpringFactoriesLoader.loadFactoryNames(type, classLoader)</code>方法我们就可以看到在之前反复提到的<code>META-INF/spring.factories</code>文件加载过程。在阅读加载过程之前，我们先找一个<code>spring.factories</code>文件看看文件结构。在这边我们就看一下<code>spring-boot-autoconfigure-2.2.5.RELEASE.jar</code>里的<code>META-INF/spring.factories</code>文件内容，<code>spring.factories</code>文件在本质上还是一个<code>properties</code>类型文件，由于该文件内容较多，我将从其中抽取部分展示，具体内容还请各位同学把Jar包Down下来研究一下。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.springframework.context.ApplicationContextInitializer</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span></span><br><span class="line"></span><br><span class="line"><span class="attr">org.springframework.context.ApplicationListener</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.BackgroundPreinitializer</span></span><br><span class="line"></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>​	我从其中抽取了些比较具有代表性的自动装配类，就包括在初始化阶段要加载得初始化器类、应用监听器、以及和我们主题密切相关得自动装配类列表。在自动装配类列表中我抽取了Redis、AOP、MongoDB的自动装配类在此作展示，其实<code>autoconfigure</code>包中还有很多我们日常开发中使用到的许多类库、中间件的自动装配类，譬如ElasticSearch、oauth2、Jap等等，就算<code>autoconfigure</code>包中没有包含我们需要的自动装配类，我们也可以依据此规则自行实现，具体实现方法我会在后面的内容进行分析，此处先行搁置。</p><p>​	在看过<code>spring.factories</code>的文件结构之后，去分析<code>SpringFactoriesLoader.loadFactoryNames</code>方法就会简单很多。传入参数<code>type</code>为需要在<code>spring.factories</code>文件集中检索的key，而返回的结果则是文件集中与之相关的所有类的全限定名。具体逻辑如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryType, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取检索类的全限定名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">factoryTypeName</span> <span class="operator">=</span> factoryType.getName();</span><br><span class="line">    <span class="comment">// 进行spring.factories文件集的加载、检索操作，并构以空集为兜底返回数据</span></span><br><span class="line">    <span class="keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">loadSpringFactories</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="comment">// spring.factories文件集在加载过一次之后会被存入缓存，避免多次进行I/O操作</span></span><br><span class="line">    MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过类加载器进行类路径下的所有META-INF/spring.factories文件进行扫描</span></span><br><span class="line">        Enumeration&lt;URL&gt; urls = (classLoader != <span class="literal">null</span> ?</span><br><span class="line">                                 classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">                                 ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">        result = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历spring.factories文件集</span></span><br><span class="line">        <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">            <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line">            <span class="type">UrlResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlResource</span>(url);</span><br><span class="line">            <span class="comment">// 将spring.factories资源转换为Propperties对象</span></span><br><span class="line">            <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">factoryTypeName</span> <span class="operator">=</span> ((String) entry.getKey()).trim();</span><br><span class="line">                <span class="comment">// 以逗号为分隔符，对类列表进行拆分遍历</span></span><br><span class="line">                <span class="keyword">for</span> (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">                    result.add(factoryTypeName, factoryImplementationName.trim());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将文件集所有结果以类加载器为Key存入内存</span></span><br><span class="line">        cache.put(classLoader, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unable to load factories from location [&quot;</span> +</span><br><span class="line">                                           FACTORIES_RESOURCE_LOCATION + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	看完这<code>spring.factories</code>文件的加载逻辑之后，我们已经知晓了自动装配的装配类来源是哪，接下来我们就需要继续弄明白，主类是如何被加载注册进容器，以及spring是如何解析注解在主类上的注解<code>@SpringBootApplication</code>及其元注解<code>EnableAutoConfiguration</code>的。</p><h3 id="Spring应用上下文的创建和准备"><a href="#Spring应用上下文的创建和准备" class="headerlink" title="Spring应用上下文的创建和准备"></a>Spring应用上下文的创建和准备</h3><p>​	在完成Spring应用的初始化阶段后，就需要开始进行启动阶段的准备工作，构建Spring应用上下文可以作为这一阶段的核心工作进行解读。</p><p>​	在Spring应用的run方法中我们可以看到Spring应用上下文的构建过程。在Spring应用初始化阶段通过类加载器推断出来的应用类型在此处就派上了用场。Spring会根据不同的应用类型初始化对应的Spring应用上下文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title function_">createApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    Class&lt;?&gt; contextClass = <span class="built_in">this</span>.applicationContextClass;</span><br><span class="line">    <span class="keyword">if</span> (contextClass == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 根据不同类型初始化对应的Spring上下文</span></span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">this</span>.webApplicationType) &#123;</span><br><span class="line">                <span class="keyword">case</span> SERVLET:</span><br><span class="line">                    contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> REACTIVE:</span><br><span class="line">                    contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                <span class="string">&quot;Unable create a default ApplicationContext, please specify an ApplicationContextClass&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对类型进行实例化操作</span></span><br><span class="line">    <span class="keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	在初始化Spring上下文的同时，我们的Bean容器，<code>BeanFactory</code>也会同时完成初始化操作。在完成初始化操作之后Spring应用上下文及Bean容器还需要完成一些准备工作以进入应用启动阶段。而主类则是在这一时间点进行的注册装配工作。</p><p>​	在此时间点，Spring上下文会完成环境变量配置、应用初始化器、通知监听器等一系列事件，但与我们所关心（主类装配）的关键代码是这么几行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">Assert.notEmpty(sources, <span class="string">&quot;Sources must not be empty&quot;</span>);</span><br><span class="line">load(context, sources.toArray(<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]));</span><br></pre></td></tr></table></figure><p>​	先通过<code>getAllSources</code>方法获取到Spring应用在初始化及准备阶段所有配置的资源内容。还记得前边说<code>SpringApplication</code>对象实例的<code>primarySources</code>储存了我们的启动类么？在这儿就用上了。我们看一看<code>getAllSources()</code>方法的内部逻辑就明白了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">getAllSources</span><span class="params">()</span> &#123;</span><br><span class="line">    Set&lt;Object&gt; allSources = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 获取储存了包括我们应用启动类的主要资源</span></span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(<span class="built_in">this</span>.primarySources)) &#123;</span><br><span class="line">        allSources.addAll(<span class="built_in">this</span>.primarySources);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取附加的配置资源</span></span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(<span class="built_in">this</span>.sources)) &#123;</span><br><span class="line">        allSources.addAll(<span class="built_in">this</span>.sources);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableSet(allSources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	获取到了主类的信息后，就可以通过<code>load(contenxt, source)</code>方法将我们的主类装在进bean容器中了。<code>Load()</code>方法的内部逻辑是Spring应用上下文的<code>BeanFactoy</code>和source构建一个<code>BeanDefinitionLoader</code>，之后检测类资源是否持有<code>@Component</code>注解（由于主类持有<code>@SpringBootApplication</code>注解，而该注解的元注解持有<code>@Configuration</code>注解，<code>@Configuration</code>的元注解中持有<code>@Compontent</code>注解，即持有判定通过），判定通过则进行类注册操作，由于这部分逻辑入栈较多，所以就不在此贴代码了，想要深入了解的同学可以自己跟着方法堆栈看一看。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>​	通过上面的内容，我们了解了Spring boot应用的元注解、自动装配的信息来源以及带有自动装配注解的主类是如何被装载进Bean容器的，Spring应用也进入了应用启动阶段。接下来的部分将会具体分析Spring在启动阶段是如何读取主类的自动装配开关以及自动装配过程是如何自动过滤不需要的自动装配类的（在<code>spring.factories</code>中我们看到了很多自动装配类，但实际我们只需要我们需求的部分，而其他的则需要被过滤掉）。</p></div><div class="post-bottom-tags-and-share border-box"><div><ul class="post-tags-box border-box"><li class="tag-item border-box"><i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/Spring-Framework/">Spring Framework</a></li><li class="tag-item border-box"><i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/Spring-Boot/">Spring Boot</a></li></ul></div><div></div></div><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2020/03/25/spring-boot-autoconfig-3/" title="Spring Boot 自动装配原理 / 3"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item text-ellipsis">Spring Boot 自动装配原理 / 3</span> <span class="post-nav-item">Prev posts</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2020/03/12/spring-boot-autoconfig-1/" title="Spring Boot 自动装配原理 / 1"><span class="title flex-center"><span class="post-nav-title-item text-ellipsis">Spring Boot 自动装配原理 / 1</span> <span class="post-nav-item">Next posts</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div></div></div><div class="pc-post-toc right-toc"><div class="post-toc-wrap border-box"><div class="post-toc border-box"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-Boot-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86-2"><span class="nav-text">Spring Boot 自动装配原理 &#x2F; 2</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E7%B1%BB%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E5%8A%A0%E8%BD%BD%E6%B3%A8%E5%86%8C%E7%9A%84"><span class="nav-text">主类是如何被加载注册的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E7%9A%84META-INF-spring-factories"><span class="nav-text">加载的META-INF&#x2F;spring.factories</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring%E5%BA%94%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%87%86%E5%A4%87"><span class="nav-text">Spring应用上下文的创建和准备</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-text">小结</span></a></li></ol></li></ol></div></div></div></div></div></div></div><div class="page-main-content-bottom border-box"><footer class="footer border-box"><div class="border-box website-info-box default"><div class="copyright-info info-item default">&copy;&nbsp;<span>2019</span>&nbsp;-&nbsp;2023 &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">ShawJie</a></div><div class="theme-info info-item default">Powered by&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;&&nbsp;Theme&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a></div><div class="icp-info info-item default"><a target="_blank" href="https://beian.miit.gov.cn">浙ICP备20000303号-1</a></div><div class="count-item info-item default"></div></div></footer></div></div><div class="post-tools right-toc"><div class="post-tools-container border-box"><ul class="tools-list border-box"><li class="tools-item flex-center toggle-show-toc"><i class="fas fa-list"></i></li></ul></div></div><div class="side-tools"><div class="side-tools-container border-box"><ul class="side-tools-list side-tools-show-handle border-box"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-toggle-theme-mode flex-center"><i class="fas fa-moon"></i></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list border-box"><li class="tools-item toggle-show-toc-tablet flex-center"><i class="fas fa-list"></i></li><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center show-arrow"><i class="arrow fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="zoom-in-image-mask"><img class="zoom-in-image"></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input"></div><span class="close-popup-btn"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div><div class="tablet-post-toc-mask"><div class="tablet-post-toc"><div class="post-toc-wrap border-box"><div class="post-toc border-box"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-Boot-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86-2"><span class="nav-text">Spring Boot 自动装配原理 &#x2F; 2</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E7%B1%BB%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E5%8A%A0%E8%BD%BD%E6%B3%A8%E5%86%8C%E7%9A%84"><span class="nav-text">主类是如何被加载注册的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E7%9A%84META-INF-spring-factories"><span class="nav-text">加载的META-INF&#x2F;spring.factories</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring%E5%BA%94%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%87%86%E5%A4%87"><span class="nav-text">Spring应用上下文的创建和准备</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-text">小结</span></a></li></ol></li></ol></div></div></div></div></main><script src="/js/utils.js"></script><script src="/js/header-shrink.js"></script><script src="/js/back2top.js"></script><script src="/js/toggle-theme.js"></script><script src="/js/code-block.js"></script><script src="/js/main.js"></script><script src="/js/libs/anime.min.js"></script><script src="/js/local-search.js"></script><script src="/js/lazyload.js"></script><div class="pjax"><script src="/js/post/post-helper.js"></script><script src="/js/post/toc.js"></script></div><script src="//cdn.jsdelivr.net/npm/mermaid@10.5.0/dist/mermaid.min.js"></script><script data-pjax>window.mermaid&&mermaid.init()</script><script src="/js/libs/pjax.min.js"></script><script>window.addEventListener("DOMContentLoaded",()=>{window.pjax=new Pjax({selectors:["head title",".page-container",".pjax"],history:!0,debug:!1,cacheBust:!1,timeout:0,analytics:!1,currentUrlFullReload:!1,scrollRestoration:!1}),document.addEventListener("pjax:send",()=>{KEEP.utils.pjaxProgressBarStart()}),document.addEventListener("pjax:complete",()=>{KEEP.utils.pjaxProgressBarEnd(),window.pjax.executeScripts(document.querySelectorAll("script[data-pjax], .pjax script")),KEEP.initExecute()})})</script><script class="custom-inject-js" src="/js/custom_home.js" data-pjax></script></body></html>