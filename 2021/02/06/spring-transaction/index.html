<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="Hexo Theme Keep"><meta name="author" content="ShawJie"><title>Spring Transaction 之 不离不弃生死相依 | Shaw&#39;s Log | 茶歇小栈</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/base_icon.ico"><link rel="stylesheet" href="/font/css/fontawesome.min.css"><link rel="stylesheet" href="/font/css/regular.min.css"><link rel="stylesheet" href="/font/css/solid.min.css"><link rel="stylesheet" href="/font/css/brands.min.css"><script class="keep-theme-configurations">const KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"shawjie.cn",root:"/",language:"en"},KEEP.theme_config={base_info:{primary_color:"#26de81",avatar:"/images/dear_kana.jpg",logo:"/images/dear_kana.jpg",favicon:"/images/base_icon.ico"},menu:{Archives:"/archives",Tags:"/tags",About:"/about"},first_screen:{enable:!0,background_img:"/images/bg.svg",background_img_dark:"/images/bg.svg",description:"愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。||能做事的做事，能发声的发声",hitokoto:!1},social_contact:{enable:!1,links:{github:null,weixin:null,qq:null,weibo:null,zhihu:null,twitter:null,facebook:null,email:null}},scroll:{progress_bar:!1,percent:!0,hide_header:!0},home:{category:!0,tag:!0,announcement:null},post:{author_badge:{enable:!1,level_badge:!0,custom_badge:["One","Two","Three"]},word_count:{wordcount:!0,min2read:!0},datetime_format:"YYYY-MM-DD HH:mm:ss",copyright_info:!1,share:!1,reward:{enable:!1,img_link:null,text:null}},code_block:{tools:{enable:!0,style:"mac"},highlight_theme:"default"},toc:{enable:!0,number:!1,expand_all:!0,init_open:!0,layout:"right"},website_count:{busuanzi_count:{enable:!1,site_uv:!0,site_pv:!0,page_pv:!0}},local_search:{enable:!1,preload:!0},comment:{enable:!1,use:"valine",valine:{appid:null,appkey:null,server_urls:null,placeholder:null},gitalk:{github_id:null,github_admins:null,repository:null,client_id:null,client_secret:null,proxy:null},twikoo:{env_id:null,region:null,version:"1.6.21"},waline:{server_url:null,reaction:!1,version:2},giscus:{repo:null,repo_id:null,category:"Announcements",category_id:null,reactions_enabled:!1},artalk:{server:null},disqus:{shortname:null}},rss:{enable:!1},lazyload:{enable:!0},cdn:{enable:!1,provider:"jsdelivr"},pjax:{enable:!0},footer:{since:2019,word_count:!1,icp:{enable:!0,record_code:"浙ICP备20000303号-1",url:"https://beian.miit.gov.cn"},site_deploy:{enable:!1,provider:"github",url:null},shields_style:{enable:!1,custom:[{link_url:null,img_url:null}]}},inject:{enable:!0,css:[null],js:["/js/shawjie_modify.js"]},root:"",version:"4.0.6"},KEEP.language_ago={second:"%s seconds ago",minute:"%s minutes ago",hour:"%s hours ago",day:"%s days ago",week:"%s weeks ago",month:"%s months ago",year:"%s years ago"},KEEP.language_code_block={copy:"Copy code",copied:"Copied",fold:"Fold code block",folded:"Folded"},KEEP.language_copy_copyright={copy:"Copy copyright info",copied:"Copied",title:"Original post title",author:"Original post author",link:"Original post link"}</script><meta name="generator" content="Hexo 7.0.0"></head><body><div class="progress-bar-container"><span class="pjax-progress-bar"></span> <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i></div><main class="page-container border-box"><div class="page-main-content border-box"><div class="page-main-content-top"><header class="header-wrapper"><div class="border-box header-content"><div class="left border-box"><a class="logo-image border-box" href="/"><img src="/images/dear_kana.jpg"> </a><a class="site-name border-box" href="/">Shaw&#39;s Log | 茶歇小栈</a></div><div class="right border-box"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">HOME</a></li><li class="menu-item"><a href="/archives">ARCHIVES</a></li><li class="menu-item"><a href="/tags">TAGS</a></li><li class="menu-item"><a href="/about">ABOUT</a></li></ul></div><div class="mobile"><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">HOME</a></li><li class="drawer-menu-item flex-center"><a href="/archives">ARCHIVES</a></li><li class="drawer-menu-item flex-center"><a href="/tags">TAGS</a></li><li class="drawer-menu-item flex-center"><a href="/about">ABOUT</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle border-box"><div class="main-content border-box"><div class="fade-in-down-animation"><div class="post-page-container border-box"><div class="post-content-container border-box"><div class="post-content-top border-box" style="height:13.8rem"><div class="cover-post-title">Spring Transaction 之 不离不弃生死相依</div><img class="post-cover" src="/images/spring-transaction/qPrDzMRxFsSbHKc.jpg" onerror='this.style.display="none"'></div><div class="post-content-bottom border-box has-cover"><div class="post-header border-box"><div class="avatar-box border-box"><img src="/images/dear_kana.jpg"></div><div class="info-box"><div class="author border-box"><span class="name">ShawJie</span></div><div class="meta-info border-box"><div class="post-meta-info-container border-box post"><div class="post-meta-info border-box"><span class="meta-info-item post-create-date"><i class="icon fa-solid fa-calendar-plus"></i>&nbsp; <span class="datetime">2021-02-06 19:57:26</span> </span><span class="meta-info-item post-update-date"><i class="icon fa-solid fa-file-pen"></i>&nbsp; <span class="datetime" data-updated="Thu Nov 30 2023 10:02:18 GMT+0800">2023-11-30 10:02:18</span> </span><span class="post-tag meta-info-item border-box"><i class="icon fas fa-tags"></i>&nbsp;<ul class="post-tag-ul"><li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/Spring-Framework/">Spring Framework</a></li><li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/Spring-Book/">Spring Book</a></li><li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/Spring-Transaction/">Spring Transaction</a></li></ul></span></div></div></div></div></div><div class="post-content keep-markdown-body"><h1 id="Spring-Transaction-之-不离不弃生死相依"><a href="#Spring-Transaction-之-不离不弃生死相依" class="headerlink" title="Spring Transaction 之 不离不弃生死相依"></a>Spring Transaction 之 不离不弃生死相依</h1><blockquote><p>事务是什么？小A排了很长很长一条多米诺骨牌序列，小C拿着相机表示：“只要你排的没有岔子，这一定是一条超酷的素材”。诶，这就是事务，不可分割，结果只有成功或者失败，没有成功了一部分之说，如果小A的骨牌序列是完美的，那小C就能得到他想要的素材，但是只要中间除了定点岔子，小A小C就啥也没有了。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​	引子的举例可能不是那么的准确，所以还是来看看<a class="link" target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Transaction_processing">Wikipedia<i class="fas fa-external-link-alt"></i></a>对事务的定义：</p><blockquote><p><strong>Transaction processing</strong> is information processing in computer science that is divided into individual, indivisible operations called <em>transactions</em>. Each transaction must succeed or fail as a complete unit;</p><p>事务处理是计算机科学中的信息处理，原子的、不可分割的操作被称作事务，每个完整单元有且只有成功或失败两个状态。</p></blockquote><p>​	事务的具体操作是数据库层面的内容，本篇内容不会有过多提及，而<code>Spring Transaction</code>更像是一个DB上层的管家，这次主要关注的是基于<code>SpringAOP</code>的<code>Spring Transaction</code>如何使我们无感知使用事务的同时肩负起事务的开启、回滚、提交操作。上次已经对<code>Spring AOP</code>的实现有过相关分析，所以也请各位对<code>AOP</code>门道还不是太清晰的小朋友移步**<a class="link" target="_blank" rel="noopener" href="https://shawjie.me/2020/12/31/Spring-aop/">SpringAOP篇<i class="fas fa-external-link-alt"></i></a>**先看看，以获得本篇更愉快的阅读体验。</p><p>​	Ps: 本篇内容所有逻辑分析是基于Spring-Boot (v2.2.9.RELEASE) 的somke-test-data-jdbc项目。Git地址: <a class="link" target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot.git">https://github.com/spring-projects/spring-boot.git<i class="fas fa-external-link-alt"></i></a>。</p><h2 id="北京猿人辈儿的事务实现"><a href="#北京猿人辈儿的事务实现" class="headerlink" title="北京猿人辈儿的事务实现"></a>北京猿人辈儿的事务实现</h2><p>​	在正式开始接触<code>Spring Transaction</code>之前，我们还是得按老规矩，先来看看北京猿人辈儿，纯JDBC时代，是怎么样开启、回滚、提交一个事务的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateSomething</span><span class="params">(Connection con, Coffee coffee, MarketGoods goods)</span> &#123;</span><br><span class="line">    <span class="comment">// 定义需要执行的语句</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">updateCoffeeSql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE coffee SET price = ? WHERE type = ?&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">updateMarketSql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE market SET sale = sale + ? WHERE coffee_type = ?&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> (</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">updateCoffee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PreparedStatement</span>(updateCoffeeSql);</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">updateMarket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PreparedStatement</span>(updateCoffeeSql)</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// 将数据库连接设置为手动提交(即开启事务)</span></span><br><span class="line">        con.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 对Sql参数进行赋值</span></span><br><span class="line">       	updateCoffee.setBigDecimal(<span class="number">1</span>, coffee.getPrice());</span><br><span class="line">        updateCoffee.setString(<span class="number">2</span>, coffee.getString());</span><br><span class="line">        <span class="comment">// 执行更新操作</span></span><br><span class="line">        updateCoffee.executeUpdate();</span><br><span class="line">        </span><br><span class="line">        ...doSomethingOthers();</span><br><span class="line">        </span><br><span class="line">        updateMarket.setInt(<span class="number">1</span>, goods.getSale());</span><br><span class="line">        updateMarket.setString(<span class="number">2</span>, goods.getCoffeeType());</span><br><span class="line">        updateMarket.executeUpdate();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 完成所有操作后对进行提交动作</span></span><br><span class="line">        con.commit();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="comment">// 执行逻辑失败后对事务进行回滚操作</span></span><br><span class="line">        logger.warn(<span class="string">&quot;execute transaction wrong&quot;</span>, e);</span><br><span class="line">        <span class="keyword">if</span> (con != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 回滚操作</span></span><br><span class="line">            	con.rollback();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException excep) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;rollback failed&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-Transaction的具体实现"><a href="#Spring-Transaction的具体实现" class="headerlink" title="Spring Transaction的具体实现"></a>Spring Transaction的具体实现</h2><blockquote><p>在上边儿咱们过了一下基于原生JDBC的事务实现逻辑，整体来看还是挺冗长的，从局部的逻辑来看设置为手动提交，以及在执行完成或执行失败时提交和回滚操作都是通用的，我们只需要关系具体的数据操作实现。那么作为事务管家的<code>Spring Transaction</code>是如何完成这部分的工作的呢？</p></blockquote><h3 id="准备阶段：管家报道"><a href="#准备阶段：管家报道" class="headerlink" title="准备阶段：管家报道"></a>准备阶段：管家报道</h3><p>​	咱在前言里稍稍提到了一嘴，说<code>Spring Transaction</code>是基于<code>AOP</code>进行实现的，那么肯定有一个<code>Advice</code>作为事务逻辑的具体执行者。先给大家透个底，具体执行者是一个叫<code>TransactionInterceptor</code>的<code>MethodInterceptor</code>类，它是哪来的呢？别急，我们慢慢看。</p><p>​	在“万物”溯源皆可溯到的<code>spring-boot-autoconfigure</code>的项目中，<code>spring.factories</code>文件里我们可以看到两个类配置，<code>TransactionAutoConfiguration</code>和<code>DataSourceTransactionManagerAutoConfiguration</code>，在<code>DataSourceTransactionManagerAutoConfiguration</code>自动配置类里，会根据我们应用的数据源，向<code>IoC</code>容器中注册事务管理器<code>DateSourceTransactionManager</code>，而<code>TransactionAutoConfiguration</code>则会在事务管理器完成注册后执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(TransactionManager.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(AbstractTransactionManagementConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EnableTransactionManagementConfiguration</span> &#123;</span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">    <span class="meta">@EnableTransactionManagement(proxyTargetClass = true)</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">                           matchIfMissing = true)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CglibAutoProxyConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	根据Spring自动装配的执行逻辑，<code>CglibAutoProxyConfiguration</code>会被认为是符合配置规则的配置类，撇开配置类的定义注解和配置规则的定义注解，那么现在我们能关注点就是在<code>@EnableTransactionManagement</code>这个注解上。嗯？你问我Spring自动装配是什么？去看看<a class="link" target="_blank" rel="noopener" href="https://shawjie.me/2020/03/12/Spring_Boot_AutoConfig_1/">这个<i class="fas fa-external-link-alt"></i></a>，虽然挺长的，但或许能解开你那一星半点儿的疑惑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(TransactionManagementConfigurationSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableTransactionManagement &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    AdviceMode <span class="title function_">mode</span><span class="params">()</span> <span class="keyword">default</span> AdviceMode.PROXY;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">order</span><span class="params">()</span> <span class="keyword">default</span> Ordered.LOWEST_PRECEDENCE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TransactionManagementConfigurationSelector</span></span><br><span class="line"><span class="keyword">protected</span> String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (adviceMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> PROXY:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;AutoProxyRegistrar.class.getName(),</span><br><span class="line">                                 ProxyTransactionManagementConfiguration.class.getName()&#125;;</span><br><span class="line">        <span class="keyword">case</span> ASPECTJ:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;determineTransactionAspectClass()&#125;;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	这个注解里引入了<code>TransactionManagementConfigurationSelector</code>配置选择类，默认的切面模式是<code>PROXY</code>，在配置选择类中根据切面模式，会加载一个叫<code>ProxyTransactionManagementConfiguration</code>配置类。当然你也可以不使用Spring默认的<code>PROXY</code>模式，转而使用<code>ASPECTJ</code>模式，那么<code>Spring Transaction</code>的切入方式就会由<code>AspectJ</code>进行实现，本篇主要关注的是<code>SpringAOP</code>实现的事务关理，所有关于<code>AspectJ</code>的事务实现就不过多分析了。</p><p>​	在<code>ProxyTransactionManagementConfiguration</code>的配置里，我们终于找到了最初的那个目标<code>TransactionInterceptor</code>，还有另一个小伙伴<code>AnnotationTransactionAttributeSource</code>，它俩相辅相成，但是我们可以晚点再说它。</p><h4 id="认领服务对象"><a href="#认领服务对象" class="headerlink" title="认领服务对象"></a>认领服务对象</h4><p>​	找到了事务逻辑的执行者后，我们得知道它是怎么和我们应用内需要事务执行的类做绑定的。上回书说道：</p><blockquote><p>Spring在从缓存里捞出所有的Advice后，会将Advice列表和Bean元信息交由<code>AopUtils#findAdvisorsThatCanApply</code>进行查找筛选并返回可匹配的Advice子集，其内部匹配逻辑由<code>org.aspectj.weaver.patterns.Pointcut#match</code>负责。<code>Pointcut#match</code>方法会判断目标类中的每个方法是否适配切面的要求，只要有一个方法符合要求，则会对目标类进行增强操作。</p></blockquote><p>​	找到包裹了我们<code>TransactionInterceptor</code>的<code>Advice</code>类<code>BeanFactoryTransactionAttributeSourceAdvisor</code>其成员属性pointcut的<code>match()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line">    <span class="type">TransactionAttributeSource</span> <span class="variable">tas</span> <span class="operator">=</span> getTransactionAttributeSource();</span><br><span class="line">    <span class="keyword">return</span> (tas == <span class="literal">null</span> || tas.getTransactionAttribute(method, targetClass) != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	在<code>getTransactionAttribute</code>中，会对检查过的方法进行缓存，在后期具体执行事务逻辑时，若缓存中方法被标记为<code>NULL_TRANSACTION_ATTRIBUTE</code>，则会跳过事务开启逻辑。由于篇幅限制，整个<code>getTransactionAttribute</code>方法中，我们主要关注其中的一小段，感兴趣的小朋友可以前往阅读剩余逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractFallbackTransactionAttributeSource#computeTransactionAttribute</span></span><br><span class="line"><span class="keyword">protected</span> TransactionAttribute <span class="title function_">computeTransactionAttribute</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 由于使用的是Cglib基于子类的增强逻辑，所以无法继承父类的私有方法</span></span><br><span class="line"><span class="comment">     * 因此要由Spring Transaction托管的方法也不能是私有方法</span></span><br><span class="line"><span class="comment">     * Ps: 至于为啥不能是protected和package-private等级的方法</span></span><br><span class="line"><span class="comment">     * 大概是SpringAOP的cglib实现要和jdkproxy一致吧</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 方法的定义及实现可能在接口上，实现类并没有给出方法的重写实现</span></span><br><span class="line"><span class="comment">     * 因此需要从定义方法的目标类上重新获得方法，</span></span><br><span class="line"><span class="comment">     * E.g ICustomerService.saveCustomer() 方法有default实现，</span></span><br><span class="line"><span class="comment">     * 但是CustomerServiceImpl并未给出saveCustomer()的重写实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">specificMethod</span> <span class="operator">=</span> AopUtils.getMostSpecificMethod(method, targetClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在特殊方法上查找是否持有@Transactional注解属性（如果没有特殊方法则会在当前方法上查找</span></span><br><span class="line">    <span class="type">TransactionAttribute</span> <span class="variable">txAttr</span> <span class="operator">=</span> findTransactionAttribute(specificMethod);</span><br><span class="line">    <span class="keyword">if</span> (txAttr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> txAttr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在特殊方法的目标类上查找@Transactional的注解属性</span></span><br><span class="line">    txAttr = findTransactionAttribute(specificMethod.getDeclaringClass());</span><br><span class="line">    <span class="keyword">if</span> (txAttr != <span class="literal">null</span> &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123;</span><br><span class="line">        <span class="keyword">return</span> txAttr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (specificMethod != method) &#123;</span><br><span class="line">        <span class="comment">// 回退到原方法上查找@Transactional注解属性</span></span><br><span class="line">        txAttr = findTransactionAttribute(method);</span><br><span class="line">        <span class="keyword">if</span> (txAttr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> txAttr;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// 回退到原方法定义类上查找@Transactional注解属性</span></span><br><span class="line">        txAttr = findTransactionAttribute(method.getDeclaringClass());</span><br><span class="line">        <span class="keyword">if</span> (txAttr != <span class="literal">null</span> &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123;</span><br><span class="line">            <span class="keyword">return</span> txAttr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	在<code>computeTransactionAttribute</code>方法中，我们可以看到Spring会在目标类上搜索<code>@Transactional</code>注解，若注解存在，则会将配置信息在内部解析器中构建为<code>RuleBasedTransactionAttribute</code>对象并缓存进<code>attributeCache</code>对象中。而底层使用的则是<code>java.lang.reflect</code>反射获取类注解信息，当Spring查找到类&#x2F;方法上标记了<code>@Transactional</code>注解时，就会将事务拦截器添加进目标类的切面链中，以进行后续的事务包装操作。</p><div style="border-radius:5px;padding:5px 15px;background-image:linear-gradient(135deg,#f5f7fa 0,#c3cfe2 100%)"><span style="color:#6a11cb">一点点小尾巴ﾉ)ﾟДﾟ( </span><p style="color:#000">&nbsp;&nbsp;在SpringFramwork2.0.x版本的<a class="link" style="color:#222" target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/2.0.x/reference/transaction.html#transaction-declarative-annotations">官方文档<i class="fas fa-external-link-alt"></i></a>中有过这么一段描述："The Spring team's recommendation is that you only annotate concrete classes with the <code>@Transactional</code> annotation, as opposed to annotating interfaces. You certainly can place the <code>@Transactional</code> annotation on an interface (or an interface method), <b style="color:#222">but this will only work as you would expect it to if you are using interface-based proxies</b>. The fact that annotations are <b style="color:#222">not inherited</b> means that if you are using class-based proxies then the transaction settings will not be recognised by the class-based proxying infrastructure and the object will not be wrapped in a transactional proxy (which would be decidedly <b style="color:#222">bad</b>)"，简单翻译一下就是：“Spring团队建议将<code>@Transactional</code>注解标记在具体的实现类而非接口上，虽然注解可以被标记在接口或接口方法上，但只在其为<b style="color:#222">基于接口代理</b>时才生效（即JDKProxy），由于注解的不可继承性，在使用<b style="color:#222">基于类代理</b>时（即CglibProxy)无法识别事务设置，以至于对象不会被事务管理器所管理”。这也是现在网络上现存的大部分博客对<code>@Transactional</code>注解进行提要时，会有<b style="color:#222">“不建议在接口上进行标记”</b>的原因所在。</p><p style="color:#000">&nbsp;&nbsp;但是依据阿消（指自己）的测试和源码逻辑阅读，在<code>SpringBoot2.2.9.RELEASE(SpringFramework5.2.8.RELEASE)</code>版本中，Spring的事务托管并不受代理实现是Cglib或是JDKProxy的影响，之和能否通过<code>getTransactionAttribute()</code>在目标方法上获取到@Transactional注解元信息有关。由于目前Github上SpringFramework的源码版本最早只能追溯到3.0.x版本，所以依然无法再了解当时SpringTransaction的实现，有了解的朋友也欢迎分享一下。虽然确实依旧还是不建议把@Transactional注解标记在接口上（因为接口只是抽象，而是否需要事务是实现应该关心的），但是原因确实和是基于类的代理实现还是基于接口的代理实现没关系了。（在SpringFramwork5的文档上已经找不到相关描述了，当然如果是我的测试步骤有问题也希望大家指正）</p></div><h3 id="事务执行：管家干活"><a href="#事务执行：管家干活" class="headerlink" title="事务执行：管家干活"></a>事务执行：管家干活</h3><blockquote><p>在上一小节，我们知道了<code>SpringTransaction</code>的事务管理器是怎么来的，以及它是怎么找到它需要服务的对象的。对象都找到了，那么作为资本家（bushi）就需要唆使打工人<code>TransactionManager</code>开始干活了。由于前文关于<code>SpringAOP</code>的流程分析是基于<code>Cglib</code>增强的，所以这部分也会按照<code>Cglib</code>的流程走，本篇可能会有较多的源码内容，也请大家耐心阅读。<code>JDKProxy</code>的流程在大体上是相似的，所以也不再赘述了。</p></blockquote><p>​	在Spring应用启动完成之后，IoC容器中存放着我们被增强后的类实例，而我们需要以事务方式执行的类或者方法，则会执行时被拦截器中的<code>TransactionInterceptor</code>事务拦截器截获，进行Spring给我们抽象好的事务包装操作。让我来看看<code>TransactionInterceptor</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 获取到被拦截的方法的目标类</span></span><br><span class="line">    Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="literal">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 调用父类TransactionAspectSupport的invokeWithinTransaction方法</span></span><br><span class="line"><span class="comment">     * 而在完成事务执行的需求判断和事务开启逻辑后，回调用invocation#proceed()方法</span></span><br><span class="line"><span class="comment">     * 以进行方法后续的逻辑运行，并等待方法的正常或异常返回，进行后续的事务提交/回滚处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	<code>TransactionInterceptor</code>中的逻辑很简单，主要的核心方法就是<code>TransactionAspectSupport#invokeWithinTransaction</code>，该方法内容比较多，整体挪过来也比较占篇幅，所以我会把部分我觉得重要的点提溜出来，剩余一些辅助性质的逻辑感兴趣的小朋友也可以自己进到方法里去看一看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">invokeWithinTransaction</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass,</span></span><br><span class="line"><span class="params">			<span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 还记得我们之前提到过会对方法的@Transactional注解信息进行缓存的TransactionAttributeSource么</span></span><br><span class="line"><span class="comment">     * 在这会根据方法和之前在TransactionInterceptor的invoke方法中获取到的目标类进行缓存的读取</span></span><br><span class="line"><span class="comment">     * 因为在增强逻辑判断中只要有一个方法符合事务的注入要求，就会对类进行增强</span></span><br><span class="line"><span class="comment">     * 所以这里也会对剩余方法进行事务执行必要的判断并缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">TransactionAttributeSource</span> <span class="variable">tas</span> <span class="operator">=</span> getTransactionAttributeSource();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 方法之前被扫描过，则会直接从缓存中读取注解信息，若方法被标记为NULL_TRANSACTION_ATTRIBUTE则会于此返回空</span></span><br><span class="line"><span class="comment">     * 反之则会在这个节点进行一次注解的扫描动作，并缓存返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">TransactionAttribute</span> <span class="variable">txAttr</span> <span class="operator">=</span> (tas != <span class="literal">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 若方法有@Tranactional注解信息，并且配置了需求的事务管理器名称</span></span><br><span class="line"><span class="comment">     * 则会在IoC容器中查找指定的事务管理器，反之则会在Ioc容器中查找TransactionManager对象</span></span><br><span class="line"><span class="comment">     * 若只存在一个，则配置为默认事务管理器并返回</span></span><br><span class="line"><span class="comment">     * 若存在多个，则需要指定一个为主要事务管理器，若不指定会直接返回空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">TransactionManager</span> <span class="variable">tm</span> <span class="operator">=</span> determineTransactionManager(txAttr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 响应式事务的实现...</span></span><br><span class="line"><span class="comment">     * 不是我们关注的重点...这次先略过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将transactionManager做一个中心接口的转换，保证多种类型的事务管理器执行流程是统一的</span></span><br><span class="line">    <span class="type">PlatformTransactionManager</span> <span class="variable">ptm</span> <span class="operator">=</span> asPlatformTransactionManager(tm);</span><br><span class="line">    <span class="comment">// 获取且入方法的限定名，作为之后创建事务的默认名称</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">joinpointIdentification</span> <span class="operator">=</span> methodIdentification(method, targetClass, txAttr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (txAttr == <span class="literal">null</span> || !(ptm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">        <span class="comment">// 进行具体的事务创建逻辑，若事务属性为空，则不会进行事务的创建执行操作</span></span><br><span class="line">        <span class="type">TransactionInfo</span> <span class="variable">txInfo</span> <span class="operator">=</span> createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);</span><br><span class="line"></span><br><span class="line">        Object retVal;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 因为连接器是链式操作，所以于此调用进行方法的后续流程执行并等待之后的流程返回</span></span><br><span class="line">            retVal = invocation.proceedWithInvocation();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">// 当方法后续流程执行出错时，则会完结当前事务，并进行一些一场事务处理逻辑，譬如回滚</span></span><br><span class="line">            completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 重置事务信息（涉及嵌套事务逻辑）</span></span><br><span class="line">            cleanupTransactionInfo(txInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当事务正常返回时进行一些后续操作，譬如提交</span></span><br><span class="line">        commitTransactionAfterReturning(txInfo);</span><br><span class="line">        <span class="comment">// 返回流程的处理结果</span></span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * CallbackPreferringPlatformTransactionManager事务管理器</span></span><br><span class="line"><span class="comment">         * 通过事务流程中的回调对事务进行提交回滚等操作</span></span><br><span class="line"><span class="comment">         * 不是本文关心重点 于此略过</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	整个事务的执行流程我们大致的先过了一遍，流程不是很复杂，相关的方法我都补充了注释，从注释当中我们能拎出几个核心方法：</p><ul><li><code>TransactionAspectSupport#createTransactionIfNecessary</code>创建事务逻辑</li><li><code>TransactionAspectSupport#completeTransactionAfterThrowing</code> 事务异常流程处理逻辑</li><li><code>TransactionAspectSupport#commitTransactionAfterReturning</code> 事务正常流程处理逻辑</li></ul><p>​	我们就按顺序一个一个往下看。</p><h4 id="创建事务-起个好头"><a href="#创建事务-起个好头" class="headerlink" title="创建事务 - 起个好头"></a>创建事务 - 起个好头</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TransactionAspectSupport#createTransactionIfNecessary</span></span><br><span class="line"><span class="keyword">protected</span> TransactionInfo <span class="title function_">createTransactionIfNecessary</span><span class="params">(<span class="meta">@Nullable</span> PlatformTransactionManager tm,</span></span><br><span class="line"><span class="params">			<span class="meta">@Nullable</span> TransactionAttribute txAttr, <span class="keyword">final</span> String joinpointIdentification)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果在@Transactional注解上没有指定事务的名称，则会使用方法限定名作为事务名称</span></span><br><span class="line">    <span class="keyword">if</span> (txAttr != <span class="literal">null</span> &amp;&amp; txAttr.getName() == <span class="literal">null</span>) &#123;</span><br><span class="line">        txAttr = <span class="keyword">new</span> <span class="title class_">DelegatingTransactionAttribute</span>(txAttr) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> joinpointIdentification;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当存在方法的事务相关标记时，并且应用内存在事务管理器则会通过</span></span><br><span class="line"><span class="comment">     * PlatformTransactionManager#getTransaction进行事务示例的创建获取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (txAttr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tm != <span class="literal">null</span>) &#123;</span><br><span class="line">            status = tm.getTransaction(txAttr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Skipping transactional joinpoint [&quot;</span> + joinpointIdentification +</span><br><span class="line">                             <span class="string">&quot;] because no transaction manager has been configured&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将事务信息封装进transactionInfo对象并与先当前线程绑定</span></span><br><span class="line">    <span class="keyword">return</span> prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	当方法不存在事务属性配置时，根据运行逻辑，不会进行相关的事务创建，而事务的创建过程<code>getTransaction</code>，则被抽象到了<code>AbstractPlatformTransactionManager</code>类上，该方法中会获取方法事务配置的事务传播等级、隔离等级，是否只读、过期时间等配置，而后会根据事务的传播等级进行相关的逻辑操作，譬如<code>PROPAGATION_MANDATORY</code>等级会在没有事务存在时抛出异常。具体每个传播等级所对应执行的逻辑操作这次就不细说了，我们主要来看看其中的<code>startTranaction</code>以及其中的<code>doBegin</code>逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractPlatformTransactionManager#startTransaction</span></span><br><span class="line"><span class="keyword">private</span> TransactionStatus <span class="title function_">startTransaction</span><span class="params">(TransactionDefinition definition, Object transaction,</span></span><br><span class="line"><span class="params">			<span class="type">boolean</span> debugEnabled, <span class="meta">@Nullable</span> SuspendedResourcesHolder suspendedResources)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 获取当前事务管理器是否是同步执行的，如果是，则会在后续的prepareSynchronization方法中</span></span><br><span class="line"><span class="comment">     * 将事务属性绑定进当前线程中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">newSynchronization</span> <span class="operator">=</span> (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">    <span class="type">DefaultTransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> newTransactionStatus(</span><br><span class="line">        definition, transaction, <span class="literal">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">    <span class="comment">// 具体的事务开启逻辑</span></span><br><span class="line">    doBegin(transaction, definition);</span><br><span class="line">    prepareSynchronization(status, definition);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 我们就来看看somke-test-data-jdbc项目中默认的TransactionManager</span></span><br><span class="line"><span class="comment"> * DataSourceTransactionManager的事务开启流程是如何操作的</span></span><br><span class="line"><span class="comment"> * DataSourceTransactionManager#doBegin</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doBegin</span><span class="params">(Object transaction, TransactionDefinition definition)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取事务对象</span></span><br><span class="line">    <span class="type">DataSourceTransactionObject</span> <span class="variable">txObject</span> <span class="operator">=</span> (DataSourceTransactionObject) transaction;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试从事务对象中获取数据库连接，若不存在连接，则会创建一个新的连接并绑定到事务上</span></span><br><span class="line">        <span class="keyword">if</span> (!txObject.hasConnectionHolder() ||</span><br><span class="line">            txObject.getConnectionHolder().isSynchronizedWithTransaction()) &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">newCon</span> <span class="operator">=</span> obtainDataSource().getConnection();</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Acquired Connection [&quot;</span> + newCon + <span class="string">&quot;] for JDBC transaction&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            txObject.setConnectionHolder(<span class="keyword">new</span> <span class="title class_">ConnectionHolder</span>(newCon), <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 标记为同步执行事务</span></span><br><span class="line">        txObject.getConnectionHolder().setSynchronizedWithTransaction(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 获取连接</span></span><br><span class="line">        con = txObject.getConnectionHolder().getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对连接进行一些前缀配置，如设置连接只读，设置连接隔离等级之类的操作</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">previousIsolationLevel</span> <span class="operator">=</span> DataSourceUtils.prepareConnectionForTransaction(con, definition);</span><br><span class="line">        <span class="comment">// 将隔离等级、是否只读信息复写回事务上</span></span><br><span class="line">        txObject.setPreviousIsolationLevel(previousIsolationLevel);</span><br><span class="line">        txObject.setReadOnly(definition.isReadOnly());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 若数据库连接的配置为自动提交，则于此改成手动提交以开启事务</span></span><br><span class="line"><span class="comment">         * 至于为什么不直接修改而是要加一层判断，Spring团队的说法是将连接设置为手动提交</span></span><br><span class="line"><span class="comment">         * 对于JDBC驱动来说是非常重的操作，他们希望在不必要的时候不进行该设置</span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        <span class="keyword">if</span> (con.getAutoCommit()) &#123;</span><br><span class="line">            txObject.setMustRestoreAutoCommit(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Switching JDBC Connection [&quot;</span> + con + <span class="string">&quot;] to manual commit&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置连接开启事务</span></span><br><span class="line">            con.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 若事务为只读事务，且事务管理器配置类显示指定只读</span></span><br><span class="line"><span class="comment">         * 则会于此开启一个会话并执行 &#x27;SET TRANSACTION READ ONLY&#x27; 显示设置事务只读</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        prepareTransactionalConnection(con, definition);</span><br><span class="line">        <span class="comment">// 标记事务为开启状态</span></span><br><span class="line">        txObject.getConnectionHolder().setTransactionActive(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置事务过期时间</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">timeout</span> <span class="operator">=</span> determineTimeout(definition);</span><br><span class="line">        <span class="keyword">if</span> (timeout != TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">            txObject.getConnectionHolder().setTimeoutInSeconds(timeout);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若事务为新开启的事务，则将连接，数据源信息绑定到当前线程中</span></span><br><span class="line">        <span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">            TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// 事务开启异常时对连接进行释放</span></span><br><span class="line">        <span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">            DataSourceUtils.releaseConnection(con, obtainDataSource());</span><br><span class="line">            txObject.setConnectionHolder(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CannotCreateTransactionException</span>(<span class="string">&quot;Could not open JDBC Connection for transaction&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	在<code>doBegin</code>方法中，我们最初想要找的，在内容开头写的那个“北京猿人辈儿”的事务开启逻辑，已经出现了。还有一个小重点，<code>SpringTransaction</code>中对数据源、连接、事务信息、方法切入点等信息绑定到线程的操作，调用的<code>TransactionSynchronizationManager</code>逻辑，都是通过<code>ThreadLocal</code>对象进行实现的，这也就是在标记为事务的方法上通过异步逻辑调用其它事务方法，会导致事务失效的原因。<code>ThreadLocal</code>对象的分析我们之后有机会再说，看到这个点的时候，或许…可以考虑一下在多线程执行事务方法时，如何保证事务不失效的逻辑。</p><h4 id="回滚事务-诶呀，出错了"><a href="#回滚事务-诶呀，出错了" class="headerlink" title="回滚事务 - 诶呀，出错了"></a>回滚事务 - 诶呀，出错了</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TransactionAspectSupport#completeTransactionAfterThrowing</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">completeTransactionAfterThrowing</span><span class="params">(<span class="meta">@Nullable</span> TransactionInfo txInfo, Throwable ex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (txInfo != <span class="literal">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取方法事务配置并判断异常是否需要回滚</span></span><br><span class="line">        <span class="keyword">if</span> (txInfo.transactionAttribute != <span class="literal">null</span> &amp;&amp; txInfo.transactionAttribute.rollbackOn(ex)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 进行具体回滚操作</span></span><br><span class="line">                txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex2) &#123;</span><br><span class="line">               <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若不需要根据配置异常回滚，则仍会进行提交操作</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex2) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在执行回滚操作时，spring会对状态进行一系列检测，譬如事务状态是否为已完成，事务是否有保存点等等</span></span><br><span class="line"><span class="comment"> * 执行完成回滚操作后，spring会将绑定在线程上的事务信息进行重置操作，我们来看看回滚的具体操作逻辑</span></span><br><span class="line"><span class="comment"> * DataSourceTransactionManager#doRollback</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRollback</span><span class="params">(DefaultTransactionStatus status)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取事务对象</span></span><br><span class="line">    <span class="type">DataSourceTransactionObject</span> <span class="variable">txObject</span> <span class="operator">=</span> (DataSourceTransactionObject) status.getTransaction();</span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> txObject.getConnectionHolder().getConnection();</span><br><span class="line">    <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Rolling back JDBC transaction on Connection [&quot;</span> + con + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行熟悉的rollback操作</span></span><br><span class="line">        con.rollback();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransactionSystemException</span>(<span class="string">&quot;Could not roll back JDBC transaction&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	在事务的回滚逻辑中还有一个点需要注意，即<code>TransactionAttribute#rollbackOn</code>方法的判定是否需要回滚，由于<code>SpringTransactionAnnotationParser</code>默认构建的是<code>RuleBasedTransactionAttribute</code>，在解析时会将<code>rollbackFor</code>、<code>rollbackForClassName</code>封装成<code>RollbackRuleAttribute</code>对象，将<code>noRollbackFor</code>、<code>noRollbackForClassName</code>封装成<code>NoRollbackRuleAttribute</code>对象并塞进rules列表中，进行后续的回滚判断操作依据，所以我们就来看看它的回滚逻辑是怎样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RuleBasedTransactionAttribute#rollbackOn</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">rollbackOn</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line">    <span class="type">RollbackRuleAttribute</span> <span class="variable">winner</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">deepest</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.rollbackRules != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取所有的回滚规则</span></span><br><span class="line">        <span class="keyword">for</span> (RollbackRuleAttribute rule : <span class="built_in">this</span>.rollbackRules) &#123;</span><br><span class="line">            <span class="comment">// 比对回滚规则并获取深度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> rule.getDepth(ex);</span><br><span class="line">            <span class="keyword">if</span> (depth &gt;= <span class="number">0</span> &amp;&amp; depth &lt; deepest) &#123;</span><br><span class="line">                <span class="comment">// 将深度最小且匹配的异常作为优选者</span></span><br><span class="line">                deepest = depth;</span><br><span class="line">                winner = rule;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当没有异常匹配时，则进行默认的回滚判断</span></span><br><span class="line"><span class="comment">     * 即若异常是RuntimeException或是Error则进行回滚操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (winner == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.rollbackOn(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若最终优选者是不需要回滚的异常类型，则不进行回滚操作，反之则进行回滚操作</span></span><br><span class="line">    <span class="keyword">return</span> !(winner <span class="keyword">instanceof</span> NoRollbackRuleAttribute);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	从以上逻辑能获取几个信息：</p><ol><li>所有的<code>RuntimeException</code>和Error都会进行回滚，除非<code>RuntimeException</code>被配置进了<code>noRollbackFor</code>列表中</li><li>回采取优胜者回滚模式进行回滚，譬如子类异常配置为不回滚，父类异常配置为回滚，因为子类异常深度更小，所以会采取子类异常的不回滚操作</li></ol><h4 id="提交事务-事情做完惹"><a href="#提交事务-事情做完惹" class="headerlink" title="提交事务 - 事情做完惹"></a>提交事务 - 事情做完惹</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TransactionAspectSupport#commitTransactionAfterReturning</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">commitTransactionAfterReturning</span><span class="params">(<span class="meta">@Nullable</span> TransactionInfo txInfo)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (txInfo != <span class="literal">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 事务管理器的提交逻辑</span></span><br><span class="line">        txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 执行提交操作的前置逻辑倒是不算复杂，会释放事务的保存点，然后进行具体的提交操作</span></span><br><span class="line"><span class="comment"> * 在提交完成后，会重置绑定在线程上的事务对象属性，但若在提交时出现RuntimeException或Error</span></span><br><span class="line"><span class="comment"> * 则仍会进行回滚操作</span></span><br><span class="line"><span class="comment"> * DataSourceTransactionManager#doCommit</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doCommit</span><span class="params">(DefaultTransactionStatus status)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取事务信息</span></span><br><span class="line">    <span class="type">DataSourceTransactionObject</span> <span class="variable">txObject</span> <span class="operator">=</span> (DataSourceTransactionObject) status.getTransaction();</span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> txObject.getConnectionHolder().getConnection();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行具体提交操作</span></span><br><span class="line">        con.commit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransactionSystemException</span>(<span class="string">&quot;Could not commit JDBC transaction&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>​	至此，我大概是把<code>SpringTransaction</code>讲清楚了吧，从头看到现在的你辛苦了，也希望你通过这个流程，知道了Spring事务在执行过程中为什么会失效，譬如没有作为<code>SpringBean</code>被<code>IoC</code>容器所管理的Bean不会被进行增强；在本类中进行<code>this.xxx</code>方法调用也不会触发事务逻辑，因为使用的是本类对象而不是增强对象；<code>@Transactional</code>注解被打在了非<code>Public</code>方法上，因为<code>Cglib</code>不会对非<code>Public</code>方法进行增强操作；异常被你用<code>try/catch</code>捕捉了导致没有触发回滚，因为<code>TransactionInterceptor</code>是在最外层进行的<code>catch</code>中进行的回滚逻辑判断。</p><p>​	总之，Spring是个怪兽，我不期望我有一天会把它理解的透彻，只希望在哪天碰到了什么问题，我会知道问题出在哪里，我该怎么解决。</p><p>​	Ps: 最近挺忙的，但是总算还是把这篇内容写完了，很长，我也知道能真真儿的读完实属不易，这篇内容写完我就要准备回家过年的事情了，也不知道有多少人会留在工作地过年…无论如何，新年快乐，还有啊…祝你在新的一年里，有人能与你共悲欢。我是阿消，新年快乐。</p></div><div class="post-bottom-tags-and-share border-box"><div><ul class="post-tags-box border-box"><li class="tag-item border-box"><i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/Spring-Framework/">Spring Framework</a></li><li class="tag-item border-box"><i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/Spring-Book/">Spring Book</a></li><li class="tag-item border-box"><i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/Spring-Transaction/">Spring Transaction</a></li></ul></div><div></div></div><div class="post-nav border-box"><div class="prev-post"><a class="prev" rel="prev" href="/2021/03/10/Spring-Application-Listener/" title="Spring Listener 之 喂，在吗？"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item text-ellipsis">Spring Listener 之 喂，在吗？</span> <span class="post-nav-item">Prev posts</span></span></a></div><div class="next-post"><a class="next" rel="next" href="/2020/12/31/Spring-aop/" title="Spring AOP 之 我的孩子为什么不一样了"><span class="title flex-center"><span class="post-nav-title-item text-ellipsis">Spring AOP 之 我的孩子为什么不一样了</span> <span class="post-nav-item">Next posts</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div></div></div><div class="pc-post-toc right-toc"><div class="post-toc-wrap border-box"><div class="post-toc border-box"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-Transaction-%E4%B9%8B-%E4%B8%8D%E7%A6%BB%E4%B8%8D%E5%BC%83%E7%94%9F%E6%AD%BB%E7%9B%B8%E4%BE%9D"><span class="nav-text">Spring Transaction 之 不离不弃生死相依</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%97%E4%BA%AC%E7%8C%BF%E4%BA%BA%E8%BE%88%E5%84%BF%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0"><span class="nav-text">北京猿人辈儿的事务实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Transaction%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="nav-text">Spring Transaction的具体实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5%EF%BC%9A%E7%AE%A1%E5%AE%B6%E6%8A%A5%E9%81%93"><span class="nav-text">准备阶段：管家报道</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A4%E9%A2%86%E6%9C%8D%E5%8A%A1%E5%AF%B9%E8%B1%A1"><span class="nav-text">认领服务对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%EF%BC%9A%E7%AE%A1%E5%AE%B6%E5%B9%B2%E6%B4%BB"><span class="nav-text">事务执行：管家干活</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%BA%8B%E5%8A%A1-%E8%B5%B7%E4%B8%AA%E5%A5%BD%E5%A4%B4"><span class="nav-text">创建事务 - 起个好头</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E6%BB%9A%E4%BA%8B%E5%8A%A1-%E8%AF%B6%E5%91%80%EF%BC%8C%E5%87%BA%E9%94%99%E4%BA%86"><span class="nav-text">回滚事务 - 诶呀，出错了</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1-%E4%BA%8B%E6%83%85%E5%81%9A%E5%AE%8C%E6%83%B9"><span class="nav-text">提交事务 - 事情做完惹</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%BE%E5%B7%B4"><span class="nav-text">尾巴</span></a></li></ol></li></ol></div></div></div></div></div></div></div><div class="page-main-content-bottom border-box"><footer class="footer border-box"><div class="border-box website-info-box default"><div class="copyright-info info-item default">&copy;&nbsp;<span>2019</span>&nbsp;-&nbsp;2024 &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">ShawJie</a></div><div class="theme-info info-item default">Powered by&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;&&nbsp;Theme&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a></div><div class="icp-info info-item default"><a target="_blank" href="https://beian.miit.gov.cn">浙ICP备20000303号-1</a></div><div class="count-item info-item default"></div></div></footer></div></div><div class="post-tools right-toc"><div class="post-tools-container border-box"><ul class="tools-list border-box"><li class="tools-item flex-center toggle-show-toc"><i class="fas fa-list"></i></li></ul></div></div><div class="side-tools"><div class="side-tools-container border-box"><ul class="side-tools-list side-tools-show-handle border-box"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-toggle-theme-mode flex-center"><i class="fas fa-moon"></i></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list border-box"><li class="tools-item toggle-show-toc-tablet flex-center"><i class="fas fa-list"></i></li><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center show-arrow"><i class="arrow fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="zoom-in-image-mask"><img class="zoom-in-image"></div><div class="tablet-post-toc-mask"><div class="tablet-post-toc"><div class="post-toc-wrap border-box"><div class="post-toc border-box"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-Transaction-%E4%B9%8B-%E4%B8%8D%E7%A6%BB%E4%B8%8D%E5%BC%83%E7%94%9F%E6%AD%BB%E7%9B%B8%E4%BE%9D"><span class="nav-text">Spring Transaction 之 不离不弃生死相依</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%97%E4%BA%AC%E7%8C%BF%E4%BA%BA%E8%BE%88%E5%84%BF%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0"><span class="nav-text">北京猿人辈儿的事务实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Transaction%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="nav-text">Spring Transaction的具体实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5%EF%BC%9A%E7%AE%A1%E5%AE%B6%E6%8A%A5%E9%81%93"><span class="nav-text">准备阶段：管家报道</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A4%E9%A2%86%E6%9C%8D%E5%8A%A1%E5%AF%B9%E8%B1%A1"><span class="nav-text">认领服务对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%EF%BC%9A%E7%AE%A1%E5%AE%B6%E5%B9%B2%E6%B4%BB"><span class="nav-text">事务执行：管家干活</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%BA%8B%E5%8A%A1-%E8%B5%B7%E4%B8%AA%E5%A5%BD%E5%A4%B4"><span class="nav-text">创建事务 - 起个好头</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E6%BB%9A%E4%BA%8B%E5%8A%A1-%E8%AF%B6%E5%91%80%EF%BC%8C%E5%87%BA%E9%94%99%E4%BA%86"><span class="nav-text">回滚事务 - 诶呀，出错了</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1-%E4%BA%8B%E6%83%85%E5%81%9A%E5%AE%8C%E6%83%B9"><span class="nav-text">提交事务 - 事情做完惹</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%BE%E5%B7%B4"><span class="nav-text">尾巴</span></a></li></ol></li></ol></div></div></div></div></main><script src="/js/utils.js"></script><script src="/js/header-shrink.js"></script><script src="/js/back2top.js"></script><script src="/js/toggle-theme.js"></script><script src="/js/code-block.js"></script><script src="/js/main.js"></script><script src="/js/libs/anime.min.js"></script><script src="/js/lazyload.js"></script><div class="pjax"><script src="/js/post/post-helper.js"></script><script src="/js/post/toc.js"></script></div><script src="//cdn.jsdelivr.net/npm/mermaid@10.5.0/dist/mermaid.min.js"></script><script data-pjax>window.mermaid&&mermaid.init()</script><script src="/js/libs/pjax.min.js"></script><script>window.addEventListener("DOMContentLoaded",()=>{window.pjax=new Pjax({selectors:["head title",".page-container",".pjax"],history:!0,debug:!1,cacheBust:!1,timeout:0,analytics:!1,currentUrlFullReload:!1,scrollRestoration:!1}),document.addEventListener("pjax:send",()=>{KEEP.utils.pjaxProgressBarStart()}),document.addEventListener("pjax:complete",()=>{KEEP.utils.pjaxProgressBarEnd(),window.pjax.executeScripts(document.querySelectorAll("script[data-pjax], .pjax script")),KEEP.initExecute()})})</script><script class="custom-inject-js" src="/js/shawjie_modify.js" data-pjax></script></body></html>