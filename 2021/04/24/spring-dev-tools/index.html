<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="Hexo Theme Keep"><meta name="author" content="ShawJie"><title>Spring DevTools 之 你总是喜新厌旧 | Shaw&#39;s Log | 茶歇小栈</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/base_icon.ico"><link rel="stylesheet" href="/font/css/fontawesome.min.css"><link rel="stylesheet" href="/font/css/regular.min.css"><link rel="stylesheet" href="/font/css/solid.min.css"><link rel="stylesheet" href="/font/css/brands.min.css"><script class="keep-theme-configurations">const KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"shawjie.cn",root:"/",language:"en"},KEEP.theme_config={base_info:{primary_color:"#26de81",avatar:"/images/dear_kana.jpg",logo:"/images/dear_kana.jpg",favicon:"/images/base_icon.ico"},menu:{Archives:"/archives",Tags:"/tags",About:"/about"},first_screen:{enable:!0,background_img:"/images/bg.svg",background_img_dark:"/images/bg.svg",description:"愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。||能做事的做事，能发声的发声",hitokoto:!1},social_contact:{enable:!1,links:{github:null,weixin:null,qq:null,weibo:null,zhihu:null,twitter:null,facebook:null,email:null}},scroll:{progress_bar:!1,percent:!0,hide_header:!0},home:{category:!0,tag:!0,announcement:null},post:{author_badge:{enable:!1,level_badge:!0,custom_badge:["One","Two","Three"]},word_count:{wordcount:!0,min2read:!0},datetime_format:"YYYY-MM-DD HH:mm:ss",copyright_info:!1,share:!1,reward:{enable:!1,img_link:null,text:null}},code_block:{tools:{enable:!0,style:"mac"},highlight_theme:"default"},toc:{enable:!0,number:!1,expand_all:!0,init_open:!0,layout:"right"},website_count:{busuanzi_count:{enable:!1,site_uv:!0,site_pv:!0,page_pv:!0}},local_search:{enable:!0,preload:!0},comment:{enable:!1,use:"valine",valine:{appid:null,appkey:null,server_urls:null,placeholder:null},gitalk:{github_id:null,github_admins:null,repository:null,client_id:null,client_secret:null,proxy:null},twikoo:{env_id:null,region:null,version:"1.6.21"},waline:{server_url:null,reaction:!1,version:2},giscus:{repo:null,repo_id:null,category:"Announcements",category_id:null,reactions_enabled:!1},artalk:{server:null},disqus:{shortname:null}},rss:{enable:!1},lazyload:{enable:!0},cdn:{enable:!1,provider:"jsdelivr"},pjax:{enable:!0},footer:{since:2019,word_count:!1,icp:{enable:!0,record_code:"浙ICP备20000303号-1",url:"https://beian.miit.gov.cn"},site_deploy:{enable:!1,provider:"github",url:null},shields_style:{enable:!1,custom:[{link_url:null,img_url:null}]}},inject:{enable:!0,css:[null],js:["/js/shawjie_modify.js"]},root:"",version:"4.0.5"},KEEP.language_ago={second:"%s seconds ago",minute:"%s minutes ago",hour:"%s hours ago",day:"%s days ago",week:"%s weeks ago",month:"%s months ago",year:"%s years ago"},KEEP.language_code_block={copy:"Copy code",copied:"Copied",fold:"Fold code block",folded:"Folded"},KEEP.language_copy_copyright={copy:"Copy copyright info",copied:"Copied",title:"Original post title",author:"Original post author",link:"Original post link"}</script><meta name="generator" content="Hexo 7.0.0"></head><body><div class="progress-bar-container"><span class="pjax-progress-bar"></span> <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i></div><main class="page-container border-box"><div class="page-main-content border-box"><div class="page-main-content-top"><header class="header-wrapper"><div class="border-box header-content"><div class="left border-box"><a class="logo-image border-box" href="/"><img src="/images/dear_kana.jpg"> </a><a class="site-name border-box" href="/">Shaw&#39;s Log | 茶歇小栈</a></div><div class="right border-box"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">HOME</a></li><li class="menu-item"><a href="/archives">ARCHIVES</a></li><li class="menu-item"><a href="/tags">TAGS</a></li><li class="menu-item"><a href="/about">ABOUT</a></li><li class="menu-item search search-popup-trigger"><i class="fas search fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">HOME</a></li><li class="drawer-menu-item flex-center"><a href="/archives">ARCHIVES</a></li><li class="drawer-menu-item flex-center"><a href="/tags">TAGS</a></li><li class="drawer-menu-item flex-center"><a href="/about">ABOUT</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle border-box"><div class="main-content border-box"><div class="fade-in-down-animation"><div class="post-page-container border-box"><div class="post-content-container border-box"><div class="post-content-top border-box" style="height:13.8rem"><div class="cover-post-title">Spring DevTools 之 你总是喜新厌旧</div><img class="post-cover" src="/images/spring-dev-tools/spWl8QoYwfVz1e6.png" onerror='this.style.display="none"'></div><div class="post-content-bottom border-box has-cover"><div class="post-header border-box"><div class="avatar-box border-box"><img src="/images/dear_kana.jpg"></div><div class="info-box"><div class="author border-box"><span class="name">ShawJie</span></div><div class="meta-info border-box"><div class="post-meta-info-container border-box post"><div class="post-meta-info border-box"><span class="meta-info-item post-create-date"><i class="icon fa-solid fa-calendar-check"></i>&nbsp; <span class="pc">2021-04-24 23:43:23</span> <span class="mobile">2021-04-24 23:43</span> </span><span class="meta-info-item post-update-date"><i class="icon fa-solid fa-file-pen"></i>&nbsp; <span class="pc" data-updated="Thu Nov 30 2023 10:02:18 GMT+0800">2023-11-30 10:02:18</span> </span><span class="post-tag meta-info-item border-box"><i class="icon fas fa-tags"></i>&nbsp;<ul class="post-tag-ul"><li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/Spring/">Spring</a></li></ul></span></div></div></div></div></div><div class="post-content keep-markdown-body"><blockquote><p><code>Spring DevTools</code>是干嘛的。试想一个场景：”一个设计师，在桌面端应用进行手机端APP UI的绘制修改工作，放在桌面上的手机展示着设计师正在编辑的图，设计师每进行一次保存，手机上的画面就会进行一次刷新，只需要低头就可以看到效果”。<code>DevTools</code>就是这种效率提升工具，在你完成代码修改后自动刷新应用，而不需要你再去在意重启应用生效的问题。</p></blockquote><h2 id="你得先知道这个"><a href="#你得先知道这个" class="headerlink" title="你得先知道这个"></a>你得先知道这个</h2><p>​	原本是想照着老规矩，先上一个工具的使用例子，但是奈何<code>DevTools</code>的使用实在是太简单了，只需要引入一个包，你就完成了全部的准备工作。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Apache Maven</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Gradle</span><br><span class="line">implementation <span class="string">&#x27;org.springframework.boot:spring-boot-devtools:2.4.4&#x27;</span></span><br></pre></td></tr></table></figure><p>​	<code>DevTools</code>的引入固然简单快捷，但是在去了解这个组件怎么工作之前我们还需要了解几个小玩意，至于为什么要了解，过会儿你就知道了。</p><h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><p>​	类加载器这玩意想必各位应该是不陌生，至少应该知道我们程序运行时加载类和资源的工作都是由它完成的。编译器会将我们的Java源文件编译成Class文件，而后运行时会由类加载器查找<strong>运行所需的类</strong>，转化为byte数值，交由native逻辑解析包装为<code>InstanceKlass</code>并装载进Java虚拟机的元空间，这是Java类的大致加载流程。</p><p>​	在我们普通的应用开发过程中，大抵接触到最多的类加载器就是<code>AppClassLoader</code>，它会加载<code>classpath</code>下，或者说我们编写的类。而其之上的<code>ExtClassLoader</code>则负责加载<code>$JAVA_HOME/lib/ext</code>，即<code>JRE</code>的扩展类。最上层的BootstrapClassLoader则加载的是Java程序的基础<code>rt.jar</code>。ClassLoader间具有一定的父子层级关系，这就扯出来了到处都在提的双亲委派逻辑：<code>在试图加载一个类时，类加载器会先尝试让父加载器先进行加载，若父加载器无法加载，才会由自身对类进行加载</code>。</p><p>​	要注意一点，不同的<code>ClassLoader</code>所加载的类是相互隔离的，什么叫相互隔离？在native逻辑层面，<code>ClassLoaderA</code>去尝试加载<code>com.shawjie.Staff</code>，在解析包装为<code>InstanceKlass</code>实例之后，会将其保存在自己的Directory中，而后<code>ClassLoaderB</code>也尝试加载了<code>Staff</code>类，解析包装完成后，也会将其保存在自己的Direcotory中。虽然在概念上加载的都是<code>Staff</code>类，但是在本质上，这是两个<code>InstanceKlass</code>实例，被保存在了不同的Directory中。因为都是native层面的东西，我这么说可能不太好理解，我们可以直接看一段简单的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义Staff类 com.shaw.demo.classloader.Staff</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Staff</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义类加载器A/B 并重写了loadClass方法</span></span><br><span class="line"><span class="comment"> * A/B类加载器逻辑相同 只有类名不同 因此只在此写出ClassLoaderA定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderA</span> <span class="keyword">extends</span> <span class="title class_">URLClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClassLoaderA</span><span class="params">(URL[] urls)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(urls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.startsWith(<span class="string">&quot;com.shaw.demo.classloader&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.loadClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取Classpath路径</span></span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader().getResource(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        URL[] urls = &#123;url&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化类加载器A/B</span></span><br><span class="line">        <span class="type">ClassLoaderA</span> <span class="variable">classLoaderA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassLoaderA</span>(urls);</span><br><span class="line">        <span class="type">ClassLoaderB</span> <span class="variable">classLoaderB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassLoaderB</span>(urls);</span><br><span class="line">	</span><br><span class="line">        <span class="comment">// 通过类加载器A/B对Staff类进行加载</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">loadedClassA</span> <span class="operator">=</span> classLoaderA.loadClass(<span class="string">&quot;com.shaw.demo.classloader.Staff&quot;</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">loadedClassB</span> <span class="operator">=</span> classLoaderB.loadClass(<span class="string">&quot;com.shaw.demo.classloader.Staff&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对比加载结果</span></span><br><span class="line">        <span class="comment">// false</span></span><br><span class="line">        System.out.println(loadedClassA == loadedClassB);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	那么，先来说说为什么采用双亲委派的设计逻辑。依着上面的例子，若是加载器A&#x2F;B都通过自己对Staff类进行加载，那么在同一个应用中，一个Staff类会有两个类定义，无法互相转换，一般没有特殊需求的话，这样同一个类的两个类定义于我们是不利的。但若是依据双亲委派模型，无论是类加载器A还是类加载器B，都会先通过其父加载器<code>AppClassLoader</code>对Staff类进行加载，这样得到的类定义也是一致的。</p><p>​	回到我们最初的那个目的，在对代码完成修改之后应用自动刷新，不需要重启应用，以实现热部署，这要怎么实现呢？结合我们刚才了解到的几点：</p><ul><li>当运行过程中需要这个类的时候，会对类执行加载操作</li><li>每个类加载器所加载的类定义在Native层面是相互隔离的</li><li>类加载器的默认加载逻辑是双亲委派，但是加载类的逻辑可以被重写</li></ul><p>​	基于这些点，结合我们的实际开发场景，我们项目所引用的外部<code>Jar</code>包是确定的，我们不会其内部类的逻辑，我们自己所编写的类是不确定的，在开发过程中，随时有可能对这些类进行修改，我们开发中的一些静态资源，如模板框架所使用的页面模板，或Css、Js之类的也是不确定的（虽然说现在大部分情况前后端分离一般也用不上）。我们是不是可以引入一个自定义类加载器，这个类加载器只负责加载我们自己编写的类，而引入的<code>Jar</code>包，则交给<code>AppClassLoader</code>进行加载，当我们对编写的类或者静态资源进行修改时，触发一个信号，而后丢弃老的自定义加载器，新建新自定义加载器，对修改后的类进行解析加载，这样是不是就能达到我们热部署的目的呢？</p><p>​	大体来说，是的。而且<code>Spring DevTools</code>正巧也是这么干的，那既然我们也有了大致思路，不如就一起来看看Spring是如何实现制这个需求的好了。哦对了，它的实现里还有部分Applcation Listener和Spring 自动装配 &#x2F; SPI相关的内容，了解了这些，看这篇内容的时候会更舒心哦，正巧这些我也有写，可以点<a class="link" target="_blank" rel="noopener" href="https://shawjie.me/">这里<i class="fas fa-external-link-alt"></i></a>去我的博客看看。</p><h2 id="正主-DevTools"><a href="#正主-DevTools" class="headerlink" title="正主 &#x2F; DevTools"></a>正主 &#x2F; DevTools</h2><p>​	在正文开始之前我们要对<code>DevTools</code>有个大概的认知。<code>DevTools</code>是SpringBoot项目的一个开发组件，虽然官方宣称<code>The spring-boot-devtools module can be included in any project to provide additional development-time features. （可以被包含在任何项目中以提供附加的即时开发特性），但是在DevTools的包中包含了大部分Spring运行必须的的组件，包括Spring-Context、AutoConfiguration等，相对来说是一个比较重的部件，而并非独立的轻量级开发者工具。所以一般情况下我还是只建议基于SpringBoot的项目使用该组件。本文相关内容依旧还是可以基于</code> v2.2.9.RELEASE 版本的 spring-boot-smoke-tests<code>下的子项目</code>spring-boot-smoke-test-devtools&#96;进行辅助阅读理解。</p><h3 id="先找到自定义加载器"><a href="#先找到自定义加载器" class="headerlink" title="先找到自定义加载器"></a>先找到自定义加载器</h3><p>​	在上一小节的末尾，我们提到了需要引入一个自定义的类加载器加载我们自己编写的类，那么这个自定义加载器在<code>DevTools</code>里是什么呢？诶，还是脱离不开我们的自动装配模块<code>AutoConfiguration</code>。在<code>spring-boot-devTools</code>项目中我们可以找到<code>Springd</code>的SPI文件<code>spring.factories</code>，让我们来看看它的具体内容：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Application Listeners</span></span><br><span class="line"><span class="attr">org.springframework.context.ApplicationListener</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.springframework.boot.devtools.restart.RestartApplicationListener</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Auto Configure</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.springframework.boot.devtools.autoconfigure.LocalDevToolsAutoConfiguration</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Environment Post Processors</span></span><br><span class="line"><span class="attr">org.springframework.boot.env.EnvironmentPostProcessor</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.springframework.boot.devtools.env.DevToolsPropertyDefaultsPostProcessor</span></span><br></pre></td></tr></table></figure><p>​	<code>DevTools</code>的SPI文件不止这些内容，我择了其中与我们内容相关性较强的配置信息出来。关于SPI的加载逻辑可以看看我之前写的自动装配篇内容，这边就不做过多讲解分析了。SpringBoot应用在启动过程中，会加载类路径下所有的<code>spring.factories</code>文件，并在初始化<code>SpringApplication</code>对象时，会将SPI文件中<code>ApplicationListener</code>配置指向的监听器配置进监听器列表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.boot.SpringApplication#SpringApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    <span class="comment">// 配置主要来源类</span></span><br><span class="line">    <span class="built_in">this</span>.primarySources = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">    <span class="built_in">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    <span class="comment">// 从SPI文件中读取配置初始化器</span></span><br><span class="line">    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">    <span class="comment">// 从SPI文件中读取配置初始化器</span></span><br><span class="line">    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">    <span class="comment">// 推断Main启动类</span></span><br><span class="line">    <span class="built_in">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	<code>Spring ApplicationListener</code>我们在上一篇内容有讲到过，我们可以具体分析一下<code>RestartApplicationListener</code>所接收的事件及其处理流程。</p><p>​	<code>RestartApplicationListener</code>实现了<code>Ordered</code>接口，并标记其优先级为最高，这意味着在装载监听器列表时，这个监听器会被第一个执行。其接接收得事件类型是<code>ApplicationEvent</code>，即<code>ApplicationEvent</code>得所有子类事件被触发时都会通知到这个监听器。<code>ApplicationEvent</code>得子事件有很多，如<code>ApplicationStartingEvent</code>、<code>ApplicationEvnviromentPrepareEvnet</code>、<code>ApplicationPrepareEvent</code>等，几乎所有Spring应用相关得事件都继承于此，但我们无需关注那么多，这回我们主要关注<code>ApplicationStartingEvent</code>事件就好了，这个事件会在<code>SpringApplication#Run</code>方法中通过<code>listeners.starting()</code>触发，我们可以看看<code>RestartApplicationListener</code>对于这个事件处理得具体实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.boot.devtools.restart.RestartApplicationListener#onApplicationStartingEvent</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">onApplicationStartingEvent</span><span class="params">(ApplicationStartingEvent event)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 从系统变量中读取 spring.devtools.restart.enabled </span></span><br><span class="line"><span class="comment">     * 判断是否要进行重开器的初始化动作 于此也意味着这个属性配置在配置文件中是无效的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">enabled</span> <span class="operator">=</span> System.getProperty(ENABLED_PROPERTY);</span><br><span class="line">    <span class="keyword">if</span> (enabled == <span class="literal">null</span> || Boolean.parseBoolean(enabled)) &#123;</span><br><span class="line">        <span class="comment">// 获取应用启动的参数</span></span><br><span class="line">        String[] args = event.getArgs();</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">         * 创建初始化器 目的是获取当前项目可被修改的资源路径</span></span><br><span class="line"><span class="comment">         * 即我们所编写的类编译后的类路径</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">DefaultRestartInitializer</span> <span class="variable">initializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultRestartInitializer</span>();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">restartOnInitialize</span> <span class="operator">=</span> !AgentReloader.isActive();</span><br><span class="line">        <span class="comment">// 进行重启器初始化操作</span></span><br><span class="line">        Restarter.initialize(args, <span class="literal">false</span>, initializer, restartOnInitialize);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 标记重启器不可用</span></span><br><span class="line">        Restarter.disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.springframework.boot.devtools.restart.Restarter#initialize</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(String[] args, <span class="type">boolean</span> forceReferenceCleanup, RestartInitializer initializer,</span></span><br><span class="line"><span class="params">                              <span class="type">boolean</span> restartOnInitialize)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 双重检查锁初始化了Restarter单例对象 </span></span><br><span class="line"><span class="comment">     * 并在对象中保存了包括启动类，可被修改资源的路径，启动参数等信息</span></span><br><span class="line"><span class="comment">     * 由于是单例对象 所以localInstance对象只会被赋值一次</span></span><br><span class="line"><span class="comment">     * 即 Restarter.initialize()方法也只会被执行一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Restarter</span> <span class="variable">localInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (INSTANCE_MONITOR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            localInstance = <span class="keyword">new</span> <span class="title class_">Restarter</span>(Thread.currentThread(), args, forceReferenceCleanup, initializer);</span><br><span class="line">            instance = localInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (localInstance != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 触发Restarter的初始化动作</span></span><br><span class="line">        localInstance.initialize(restartOnInitialize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	跟到这，可以说我们已经近乎贴到了真相。<code>Restarter</code>实例的<code>initialize</code>方法会通过在构造方法里初始化的<code>LeakSafeThread（泄露安全线程）</code>通过<code>start() + join()</code>的模式插入到当前线程进行具体<code>Restarter</code>的启动流程。由于这段逻辑中间的碎片方法比较多，就让我们直接跳到核心部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.boot.devtools.restart.Restarter#doStart</span></span><br><span class="line"><span class="keyword">private</span> Throwable <span class="title function_">doStart</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="comment">// 将我们的可被修改资源的路径构建为URL数组</span></span><br><span class="line">    URL[] urls = <span class="built_in">this</span>.urls.toArray(<span class="keyword">new</span> <span class="title class_">URL</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 终究还是让我们找到了 自定义的类加载器</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestartClassLoader</span>(<span class="built_in">this</span>.applicationClassLoader, urls, updatedFiles, <span class="built_in">this</span>.logger);</span><br><span class="line">    <span class="keyword">return</span> relaunch(classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Throwable <span class="title function_">relaunch</span><span class="params">(ClassLoader classLoader)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * RestartLauncher 继承于Thread类 在构造方法中</span></span><br><span class="line"><span class="comment">     * 将刚创建的自定义类加载器设定为上下文的类加载器</span></span><br><span class="line"><span class="comment">     * 并保存了启动类，启动参数信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">RestartLauncher</span> <span class="variable">launcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestartLauncher</span>(classLoader, <span class="built_in">this</span>.mainClassName, <span class="built_in">this</span>.args,</span><br><span class="line">                                                   <span class="built_in">this</span>.exceptionHandler);</span><br><span class="line">    <span class="comment">// 启动线程</span></span><br><span class="line">    launcher.start();</span><br><span class="line">    <span class="comment">// 切入当前线程</span></span><br><span class="line">    launcher.join();</span><br><span class="line">    <span class="keyword">return</span> launcher.getError();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	在<code>ResarterLauncher</code>线程的<code>run</code>方法中，使用方法反射调用了我们启动类的main方法，并原封不动的传入了启动参数，悄咪咪的用<code>restartMain</code>线程置换掉了我们默认的<code>main</code>线程，重新启动了一次我们的应用。那<code>main</code>线程又去哪呢？还记得我们刚才说的被插入到main线程的<code>LakeSafeThread</code>线程么？在<code>RestarterLauncher</code>完成再次启动应用的流程后，泄露安全线程因为所有逻辑已执行完毕且守护线程已关闭，所以会直接退出，而main线程则会通过<code>SilentExitExceptionHandler.exitCurrentThread();</code>方法调用被退出。（线程退出方法在<code>org.springframework.boot.devtools.restart.Restarter#immediateRestart</code>，感兴趣的朋友可以去瞅瞅）</p><p>​	换句话说，之后承载我们<code>Spring</code>应用运行的是<code>restartMain</code>线程而非平时的<code>main</code>线程。这两者的区别在于<code>restartMain</code>线程的上下文类加载器是自定义的<code>restartClassLoader</code>，而<code>main</code>线程的上下文类加载器是<code>AppClassLoader</code>。</p><p>​	在<code>ClassLoader</code>小节中我特意加粗了这部分描述：”运行时会由类加载器查找<strong>运行所需的类</strong>“。在第一次应用启动时，由于启动流程被<code>RestartApplicationListener</code>截胡并重新以<code>RestartLauncher</code>启动应用，在此之前Spring还并没有到Bean扫描阶段，因此我们所编写的类也还未被加载。在第二次通过反射方法调用启动应用之后，不会再被截胡，正常流转到<code>Bean</code>扫描装配流程，此时才会由<code>RestarterClassLoader</code>去尝试加载我们所编写的类。而<code>RestartClassLoader</code>实现于<code>URLClassLoader</code>基础之上(<code>URLClassLoader</code>会尝试去构造时传入的URL下搜寻类，在<code>RestartClassLoader</code>中就是我们的编写的类)，并重写了<code>loadClass</code>方法，若搜寻不到目标类，则会由父类加载器<code>AppClassLoader</code>进行类加载动作。即<code>RestartClassLoader</code>会加载所有运行时所用到的我们编写的类，而JAR中的类则交付予了<code>AppClassLoader</code>或更上层的类加载器进行加载。</p><p>​	至此，我们完成了流程的第一步，找到了只加载我们的类的自定义类加载器。这是整个<code>DevTools</code>比较精髓的部分，整体实现也相对复杂，也希望大家静下心就着代码慢慢理解。</p><h3 id="怎么知道资源变动了"><a href="#怎么知道资源变动了" class="headerlink" title="怎么知道资源变动了"></a>怎么知道资源变动了</h3><p>​	当然，光找到自定义类加载器还不够，<code>DevTools</code>还需要知道我们对类、对静态资源的修改动作，并以此为依据触发信号通知我们的<code>Restarter</code>执行重启操作。在<code>DevTools</code>项目的<code>spring.facotiries</code>文件中我们可以看到一个自动装配类<code>LocalDevToolsAutoConfiguration</code>，让我们把它拎出来看看。（老规矩，我还是会忽略掉一些和本节相关性不强的内容）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 自动装配的OnCondition逻辑</span></span><br><span class="line"><span class="comment"> * 在Restarter对象实例没有被初始化时 该类不会被自动装配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ConditionalOnInitializedRestarter</span></span><br><span class="line"><span class="comment">// 将配置信息装载进DevToolsProperties对象中</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(DevToolsProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalDevToolsAutoConfiguration</span> &#123;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 只有当显示配置了spring.devtools.restart.enable=false时</span></span><br><span class="line"><span class="comment">     * 该配置类才不会被装载 反之则会进行装载配置动作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="meta">@ConditionalOnProperty(prefix = &quot;spring.devtools.restart&quot;, name = &quot;enabled&quot;, matchIfMissing = true)</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RestartConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> DevToolsProperties properties;</span><br><span class="line"></span><br><span class="line">		RestartConfiguration(DevToolsProperties properties) &#123;</span><br><span class="line">			<span class="built_in">this</span>.properties = properties;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">     	</span><br><span class="line">     	 <span class="comment">// 这里创建了一个监听器，监听ClassPathChangedEvent事件</span></span><br><span class="line">         <span class="meta">@Bean</span></span><br><span class="line">		ApplicationListener&lt;ClassPathChangedEvent&gt; <span class="title function_">restartingClassPathChangedEventListener</span><span class="params">(</span></span><br><span class="line"><span class="params">				FileSystemWatcherFactory fileSystemWatcherFactory)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> (event) -&gt; &#123;</span><br><span class="line">                  <span class="comment">//  当事件标记为需要重启时通过Restarter实例的restart方法进行重启动作</span></span><br><span class="line">				<span class="keyword">if</span> (event.isRestartRequired()) &#123;</span><br><span class="line">                      <span class="comment">// 那么现在重启动作的执行者已经找到了 现在就要找到信号的发出者了</span></span><br><span class="line">					Restarter.getInstance().restart(<span class="keyword">new</span> <span class="title class_">FileWatchingFailureHandler</span>(fileSystemWatcherFactory));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 于此创建了一个ClassPathFileSystemWatcher对象</span></span><br><span class="line"><span class="comment">         * 光从对象名称上就能知道这是个监控类文件系统的对象 我们大概能于此着手</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">		ClassPathFileSystemWatcher <span class="title function_">classPathFileSystemWatcher</span><span class="params">(FileSystemWatcherFactory fileSystemWatcherFactory,</span></span><br><span class="line"><span class="params">				ClassPathRestartStrategy classPathRestartStrategy)</span> &#123;</span><br><span class="line">             <span class="comment">// 这里获取到的initialUrls就是可被修改资源的路径</span></span><br><span class="line">			URL[] urls = Restarter.getInstance().getInitialUrls();</span><br><span class="line">			<span class="type">ClassPathFileSystemWatcher</span> <span class="variable">watcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathFileSystemWatcher</span>(fileSystemWatcherFactory,</span><br><span class="line">					classPathRestartStrategy, urls);</span><br><span class="line">             <span class="comment">// 配置监视器再重启时暂停工作</span></span><br><span class="line">			watcher.setStopWatcherOnRestart(<span class="literal">true</span>);</span><br><span class="line">			<span class="keyword">return</span> watcher;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	<code>ClassPathFileSystemWatch</code>实现了<code>InitialingBean</code>，在被IoC容器进行管理之后，会通过钩子方法<code>afterPropertiesSet</code>向监视器注册处理逻辑的监听器而后启动监听器。在监视器启动前，会针对可被修改资源创建快照，而后启动一个监视器线程，根据配置的轮询时间对可被修改资源创建快照，并将新快照与老快照进行对比，若快照文件集不同（对比文件集Hash）则会扫描更新具体被修改的文件列表（通过比对文件是否存在、长度、最后更新时间），并通知监视器内部的监听器。</p><p>​	监听器则会根据被修改的文件列表，判断其中是否含有除静态资源、测试类、git属性文件或自定义附加的一些文件之外的内容，如果有，则标记为需要重启，反之则标记为不需要重启。完成标记判断后，会通过<code>ApplicationEventPubliusher</code>触发<code>ClassPathChangedEvent</code>事件。诶，在刚刚的自动装配类里出现的监听器就派上用场了。</p><p>​	在监听器中通过<code>restart</code>方法对应用进行自动重启。而具体操作逻辑就是关闭Spring应用上下文，清除缓存，尝试触发垃圾回收，以及执行对象的<code>finalize</code>方法，Spring应用上下文关闭后，原本承载应用运行的<code>RestartLauncher</code>也会停止，在停止流程完成后，会通过<code>doStart</code>方法启动应用，这个方法的执行逻辑已经在上一小节瞅过了，这边儿就不再重复了，而原本绑定在<code>RestartLauncher</code>线程上的类加载器也会由于线程的停止被标记为不可达并等待GC的回收，应用启动之后又会有一个空的类加载器在等待着加载我们的类。</p><p>​	用文字书写的逻辑到底还是稍显宽泛，所有大伙儿可以先把流程了解一下，我们套进具体链路把实现再看一遍。(Ps: 接下来会有很长一段逻辑，但是我都标注了做用，可以慢慢看)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.boot.devtools.classpath.ClassPathFileSystemWatcher#afterPropertiesSet</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 若有配置重启策略，则会将其配置进监视器的监听器中</span></span><br><span class="line"><span class="comment">     * 用于后续的的逻辑处理 但是实际上如果没有重启策略</span></span><br><span class="line"><span class="comment">     * 以导致于此不会向监视器中添加监听器 从而导致监视器即使检测到了文件改动</span></span><br><span class="line"><span class="comment">     * 也没有任何逻辑会去把这个信号向外发出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.restartStrategy != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">FileSystemWatcher</span> <span class="variable">watcherToStop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 限制监视器是否要在重启阶段停止运行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.stopWatcherOnRestart) &#123;</span><br><span class="line">            watcherToStop = <span class="built_in">this</span>.fileSystemWatcher;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加监听器</span></span><br><span class="line">        <span class="built_in">this</span>.fileSystemWatcher.addListener(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ClassPathFileChangeListener</span>(<span class="built_in">this</span>.applicationContext, <span class="built_in">this</span>.restartStrategy, watcherToStop));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动监视器</span></span><br><span class="line">    <span class="built_in">this</span>.fileSystemWatcher.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.springframework.boot.devtools.filewatch.FileSystemWatcher#start</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.monitor) &#123;</span><br><span class="line">        <span class="comment">// 针对可被修改资源创建文件快照</span></span><br><span class="line">        saveInitialSnapshots();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.watchThread == <span class="literal">null</span>) &#123;</span><br><span class="line">            Map&lt;File, FolderSnapshot&gt; localFolders = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="built_in">this</span>.folders);</span><br><span class="line">            <span class="comment">// 配置监视器线程</span></span><br><span class="line">            <span class="built_in">this</span>.watchThread = <span class="keyword">new</span> <span class="title class_">Thread</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Watcher</span>(</span><br><span class="line">                    <span class="built_in">this</span>.remainingScans, </span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.listeners), </span><br><span class="line">                    <span class="built_in">this</span>.triggerFilter, </span><br><span class="line">                    <span class="built_in">this</span>.pollInterval, </span><br><span class="line">                    <span class="built_in">this</span>.quietPeriod, </span><br><span class="line">                    localFolders)</span><br><span class="line">            );</span><br><span class="line">            <span class="built_in">this</span>.watchThread.setName(<span class="string">&quot;File Watcher&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.watchThread.setDaemon(<span class="built_in">this</span>.daemon);</span><br><span class="line">            <span class="comment">// 启动监视器线程</span></span><br><span class="line">            <span class="built_in">this</span>.watchThread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 由于构建监视器的Watcher对象实现了Runnable类，所以我们可以直接看它的run方法</span></span><br><span class="line"><span class="comment"> * org.springframework.boot.devtools.filewatch.FileSystemWatcher.Watcher#run</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取剩余扫描次数 若为-1则代表无限次扫描</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">remainingScans</span> <span class="operator">=</span> <span class="built_in">this</span>.remainingScans.get();</span><br><span class="line">    <span class="keyword">while</span> (remainingScans &gt; <span class="number">0</span> || remainingScans == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (remainingScans &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.remainingScans.decrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 具体扫描逻辑</span></span><br><span class="line">            scan();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 若配置了在重启阶段停止运行</span></span><br><span class="line"><span class="comment">             * 则会在停止方法中触发中断信号退出当前线程</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        remainingScans = <span class="built_in">this</span>.remainingScans.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.springframework.boot.devtools.filewatch.FileSystemWatcher.Watcher#scan</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scan</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 根据配置的轮询间隔进行线程停顿</span></span><br><span class="line">    Thread.sleep(<span class="built_in">this</span>.pollInterval - <span class="built_in">this</span>.quietPeriod);</span><br><span class="line">    Map&lt;File, FolderSnapshot&gt; previous;</span><br><span class="line">    Map&lt;File, FolderSnapshot&gt; current = <span class="built_in">this</span>.folders;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        previous = current;</span><br><span class="line">        <span class="comment">// 获取当前的可变资源快照</span></span><br><span class="line">        current = getCurrentSnapshots();</span><br><span class="line">        Thread.sleep(<span class="built_in">this</span>.quietPeriod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将当前的快照和目前的快照进行对比</span></span><br><span class="line">    <span class="keyword">while</span> (isDifferent(previous, current));</span><br><span class="line">    <span class="keyword">if</span> (isDifferent(<span class="built_in">this</span>.folders, current)) &#123;</span><br><span class="line">        <span class="comment">// 更新快照内容</span></span><br><span class="line">        updateSnapshots(current.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.springframework.boot.devtools.filewatch.FileSystemWatcher.Watcher#updateSnapshots</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateSnapshots</span><span class="params">(Collection&lt;FolderSnapshot&gt; snapshots)</span> &#123;</span><br><span class="line">    Map&lt;File, FolderSnapshot&gt; updated = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">    Set&lt;ChangedFiles&gt; changeSet = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (FolderSnapshot snapshot : snapshots) &#123;</span><br><span class="line">        <span class="comment">// 获取到文件集快照</span></span><br><span class="line">        <span class="type">FolderSnapshot</span> <span class="variable">previous</span> <span class="operator">=</span> <span class="built_in">this</span>.folders.get(snapshot.getFolder());</span><br><span class="line">        updated.put(snapshot.getFolder(), snapshot);</span><br><span class="line">        <span class="comment">// 通过对比文件是否存在、长度、最后修改时间判定文件是否被修改</span></span><br><span class="line">        <span class="type">ChangedFiles</span> <span class="variable">changedFiles</span> <span class="operator">=</span> previous.getChangedFiles(snapshot, <span class="built_in">this</span>.triggerFilter);</span><br><span class="line">        <span class="keyword">if</span> (!changedFiles.getFiles().isEmpty()) &#123;</span><br><span class="line">            changeSet.add(changedFiles);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!changeSet.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 触发监听器</span></span><br><span class="line">        fireListeners(Collections.unmodifiableSet(changeSet));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.folders = updated;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ClassPathFileChangeListener在监视器对象初始化时被添加</span></span><br><span class="line"><span class="comment"> * 因此我们可以看看它的对于事件的处理逻辑</span></span><br><span class="line"><span class="comment"> * 监视器内部的监听器不同于普通的SpringApplicationListener</span></span><br><span class="line"><span class="comment"> * 因此也并不能通过实现bean进行自动注入</span></span><br><span class="line"><span class="comment"> * org.springframework.boot.devtools.classpath.ClassPathFileChangeListener#onChange</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChange</span><span class="params">(Set&lt;ChangedFiles&gt; changeSet)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据策略判断是否需要重启</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">restart</span> <span class="operator">=</span> isRestartRequired(changeSet);</span><br><span class="line">    <span class="comment">// 通过ApplicationEventPublisher发布类路径修改的事件</span></span><br><span class="line">    publishEvent(<span class="keyword">new</span> <span class="title class_">ClassPathChangedEvent</span>(<span class="built_in">this</span>, changeSet, restart));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​	至此，<code>DevTools</code>的主流程及其实现我们是走完了，也顺应着最初的推论找到了<code>DevTools</code>的两个核心，自定义类加载器，及文件修改的监视器。总而言之<code>ClassLoader</code>这玩意是个可玩性很高的东西，除了在本地开发实现热更新之外，你甚至能在生产环境通过它实现热部署，譬如Tomcat的<code>WebappClassLoader</code>。当然，整个<code>DevTools</code>工具除了自动重启的功能，还有自动刷新web以使其重新加载资源，以及我们内容里体到的<code>LocalDevToolsAutoConfiguration</code>自然也有个相对的<code>RemoteDevToolsAutoConfiguration</code>以实现远程自动重启更新应用的功能支持。</p><h4 id="LiveReload"><a href="#LiveReload" class="headerlink" title="LiveReload"></a>LiveReload</h4><p>​	在自动装配类<code>LocalDevToolsAutoConfiguration</code>里还有个<code>LiveReloadServer</code>，与其配合的还有一个Chrome插件<a class="link" target="_blank" rel="noopener" href="https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei/relate">LiveReload<i class="fas fa-external-link-alt"></i></a>。<code>LiveReloadServer</code>在没有配置<code>spring.devtools.livereload.enable=false</code>时会默认进行启动，并开启一个WebScoket与应用外部的插件建立联系。当我们的开发时，若只对静态资源做了修改，譬如Js、Css文件，文件修改监视器会发出标记为<code>restartRequire</code>为<code>false</code>的事件，而<code>LiveReloadServerEventListener</code>在接受到这个事件之后会通过WebSocket向与之建立连接的客户端，也就是我们的浏览器插件发出一个重新加载信号，插件会触发<code>window.localtion.reload()</code>方法以重新加载资源。</p><p>​	哦对了，被认为不需要进行重启的文件覆盖范围是<code>META-INF/maven/**, META-INF/resources/**,resources/**,static/**,public/**,templates/**, **/*Test.class,**/*Tests.class,git.properties,META-INF/build-info.properties</code>，若还需要新增范围，可通过配置<code>spring.devtools.restart.additionalExclude</code>，复写范围也可以通过配置<code>spring.devtools.restart.exclude</code>。</p><h4 id="RemoteDevTools"><a href="#RemoteDevTools" class="headerlink" title="RemoteDevTools"></a>RemoteDevTools</h4><p>​	<code>RemoteDevTools</code>支持远程自动重启更新应用，但是实现的主逻辑还是脱离不开最核心的自定义类加载器和文件变更监视器，与本地环境的区别也只是类加载器的重载动作在远端，文件扫描监视器的扫描动作在本地罢了。需要远端调试开发的应用配置<code>spring.devtools.remote.secret</code>属性，这是一个开关，用于激活<code>RemoteDevToolsAutoConfiguration</code>自动装配类，也用于与远端连接进行身份验证，远端的应用在部署完成之后会向外暴露一个<code>restart</code>接口，而本地的应用以<code>RemoteSpringApplication</code>作为启动类，在<code>ClassPathChangedEvent</code>事件被触发时，调用接口上传被更新的文件并在远端触发<code>restart</code>动作，而后流程与本地环境开发无异。</p><h4 id="杂的"><a href="#杂的" class="headerlink" title="杂的"></a>杂的</h4><p>​	在读<code>DevTools</code>的时候看到了一段Spring挺有意思的源码，是用于在<code>Restarter</code>执行重启动作时候用于清除软引用 &#x2F; 弱引用的，但是依据默认逻辑并不会执行，觉得有意思所以放出来给大家看看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.boot.devtools.restart.Restarter#forceReferenceCleanup</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">forceReferenceCleanup</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;<span class="type">long</span>[]&gt; memory = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 不断的向数组内存放大对象 用于促使GC回收软引用弱引用、</span></span><br><span class="line"><span class="comment">             * 当抛出OutOfMemory错误时 确保已经清除了所有软引用/弱引用</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            memory.add(<span class="keyword">new</span> <span class="title class_">long</span>[<span class="number">102400</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (OutOfMemoryError ex) &#123;</span><br><span class="line">        <span class="comment">// 期望</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>​	四月初去长沙转了一圈儿，长沙的东西确实好吃，茶颜悦色也确实好喝。人嘛，总是怠惰的，回来之后开始准备这个月的内容，折腾着这那的到底还是磨蹭到了近乎月底。Spring的组件我觉着我已经写了挺多的，剩下一些可能还会揉在一起再写一篇？大概吧。再之后…可能会去看点别的内容，譬如<code>RocketMq</code>、<code>Kafka</code>之类的。总之，还是谢谢你能看到这里，也辛苦我写到这里，爱人如己，这是我这段时间听到的一个最喜欢的词，希望你能加油，我也是…晚安。</p></div><div class="post-bottom-tags-and-share border-box"><div><ul class="post-tags-box border-box"><li class="tag-item border-box"><i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/Spring/">Spring</a></li></ul></div><div></div></div><div class="post-nav border-box"><div class="prev-post"><a class="prev" rel="prev" href="/2022/03/14/spring-boot-release-note/" title="Spring boot 版本更新记录"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item text-ellipsis">Spring boot 版本更新记录</span> <span class="post-nav-item">Prev posts</span></span></a></div><div class="next-post"><a class="next" rel="next" href="/2021/03/10/Spring-Application-Listener/" title="Spring Listener 之 喂，在吗？"><span class="title flex-center"><span class="post-nav-title-item text-ellipsis">Spring Listener 之 喂，在吗？</span> <span class="post-nav-item">Next posts</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div></div></div><div class="pc-post-toc right-toc"><div class="post-toc-wrap border-box"><div class="post-toc border-box"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%A0%E5%BE%97%E5%85%88%E7%9F%A5%E9%81%93%E8%BF%99%E4%B8%AA"><span class="nav-text">你得先知道这个</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ClassLoader"><span class="nav-text">ClassLoader</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E4%B8%BB-DevTools"><span class="nav-text">正主 &#x2F; DevTools</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%88%E6%89%BE%E5%88%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-text">先找到自定义加载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93%E8%B5%84%E6%BA%90%E5%8F%98%E5%8A%A8%E4%BA%86"><span class="nav-text">怎么知道资源变动了</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-text">小结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LiveReload"><span class="nav-text">LiveReload</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RemoteDevTools"><span class="nav-text">RemoteDevTools</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%82%E7%9A%84"><span class="nav-text">杂的</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%BE%E5%B7%B4"><span class="nav-text">尾巴</span></a></li></ol></div></div></div></div></div></div></div><div class="page-main-content-bottom border-box"><footer class="footer border-box"><div class="border-box website-info-box default"><div class="copyright-info info-item default">&copy;&nbsp;<span>2019</span>&nbsp;-&nbsp;2023 &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">ShawJie</a></div><div class="theme-info info-item default">Powered by&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;&&nbsp;Theme&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a></div><div class="icp-info info-item default"><a target="_blank" href="https://beian.miit.gov.cn">浙ICP备20000303号-1</a></div><div class="count-item info-item default"></div></div></footer></div></div><div class="post-tools right-toc"><div class="post-tools-container border-box"><ul class="tools-list border-box"><li class="tools-item flex-center toggle-show-toc"><i class="fas fa-list"></i></li></ul></div></div><div class="side-tools"><div class="side-tools-container border-box"><ul class="side-tools-list side-tools-show-handle border-box"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-toggle-theme-mode flex-center"><i class="fas fa-moon"></i></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list border-box"><li class="tools-item toggle-show-toc-tablet flex-center"><i class="fas fa-list"></i></li><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center show-arrow"><i class="arrow fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="zoom-in-image-mask"><img class="zoom-in-image"></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input"></div><span class="close-popup-btn"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div><div class="tablet-post-toc-mask"><div class="tablet-post-toc"><div class="post-toc-wrap border-box"><div class="post-toc border-box"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%A0%E5%BE%97%E5%85%88%E7%9F%A5%E9%81%93%E8%BF%99%E4%B8%AA"><span class="nav-text">你得先知道这个</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ClassLoader"><span class="nav-text">ClassLoader</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E4%B8%BB-DevTools"><span class="nav-text">正主 &#x2F; DevTools</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%88%E6%89%BE%E5%88%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-text">先找到自定义加载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93%E8%B5%84%E6%BA%90%E5%8F%98%E5%8A%A8%E4%BA%86"><span class="nav-text">怎么知道资源变动了</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-text">小结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LiveReload"><span class="nav-text">LiveReload</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RemoteDevTools"><span class="nav-text">RemoteDevTools</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%82%E7%9A%84"><span class="nav-text">杂的</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%BE%E5%B7%B4"><span class="nav-text">尾巴</span></a></li></ol></div></div></div></div></main><script src="/js/utils.js"></script><script src="/js/header-shrink.js"></script><script src="/js/back2top.js"></script><script src="/js/toggle-theme.js"></script><script src="/js/code-block.js"></script><script src="/js/main.js"></script><script src="/js/libs/anime.min.js"></script><script src="/js/local-search.js"></script><script src="/js/lazyload.js"></script><div class="pjax"><script src="/js/post/post-helper.js"></script><script src="/js/post/toc.js"></script></div><script src="//cdn.jsdelivr.net/npm/mermaid@10.5.0/dist/mermaid.min.js"></script><script data-pjax>window.mermaid&&mermaid.init()</script><script src="/js/libs/pjax.min.js"></script><script>window.addEventListener("DOMContentLoaded",()=>{window.pjax=new Pjax({selectors:["head title",".page-container",".pjax"],history:!0,debug:!1,cacheBust:!1,timeout:0,analytics:!1,currentUrlFullReload:!1,scrollRestoration:!1}),document.addEventListener("pjax:send",()=>{KEEP.utils.pjaxProgressBarStart()}),document.addEventListener("pjax:complete",()=>{KEEP.utils.pjaxProgressBarEnd(),window.pjax.executeScripts(document.querySelectorAll("script[data-pjax], .pjax script")),KEEP.initExecute()})})</script><script class="custom-inject-js" src="/js/shawjie_modify.js" data-pjax></script></body></html>