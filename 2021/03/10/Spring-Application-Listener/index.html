<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="Hexo Theme Keep"><meta name="author" content="ShawJie"><title>Spring Listener 之 喂，在吗？ | Shaw&#39;s Log | 茶歇小栈</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/base_icon.ico"><link rel="stylesheet" href="/font/css/fontawesome.min.css"><link rel="stylesheet" href="/font/css/regular.min.css"><link rel="stylesheet" href="/font/css/solid.min.css"><link rel="stylesheet" href="/font/css/brands.min.css"><script class="keep-theme-configurations">const KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"shawjie.cn",root:"/",language:"en"},KEEP.theme_config={base_info:{primary_color:"#26de81",avatar:"/images/dear_kana.jpg",logo:"/images/dear_kana.jpg",favicon:"/images/base_icon.ico"},menu:{Archives:"/archives",Tags:"/tags",About:"/about"},first_screen:{enable:!0,background_img:"/images/bg.svg",background_img_dark:"/images/bg.svg",description:"愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。||能做事的做事，能发声的发声",hitokoto:!1},social_contact:{enable:!1,links:{github:null,weixin:null,qq:null,weibo:null,zhihu:null,twitter:null,facebook:null,email:null}},scroll:{progress_bar:!1,percent:!0,hide_header:!0},home:{category:!0,tag:!0,announcement:null},post:{author_badge:{enable:!1,level_badge:!0,custom_badge:["One","Two","Three"]},word_count:{wordcount:!0,min2read:!0},datetime_format:"YYYY-MM-DD HH:mm:ss",copyright_info:!1,share:!1,reward:{enable:!1,img_link:null,text:null}},code_block:{tools:{enable:!0,style:"mac"},highlight_theme:"default"},toc:{enable:!0,number:!1,expand_all:!0,init_open:!0,layout:"right"},website_count:{busuanzi_count:{enable:!1,site_uv:!0,site_pv:!0,page_pv:!0}},local_search:{enable:!0,preload:!0},comment:{enable:!1,use:"valine",valine:{appid:null,appkey:null,server_urls:null,placeholder:null},gitalk:{github_id:null,github_admins:null,repository:null,client_id:null,client_secret:null,proxy:null},twikoo:{env_id:null,region:null,version:"1.6.21"},waline:{server_url:null,reaction:!1,version:2},giscus:{repo:null,repo_id:null,category:"Announcements",category_id:null,reactions_enabled:!1},artalk:{server:null},disqus:{shortname:null}},rss:{enable:!1},lazyload:{enable:!0},cdn:{enable:!1,provider:"jsdelivr"},pjax:{enable:!0},footer:{since:2019,word_count:!1,icp:{enable:!0,record_code:"浙ICP备20000303号-1",url:"https://beian.miit.gov.cn"},site_deploy:{enable:!1,provider:"github",url:null},shields_style:{enable:!1,custom:[{link_url:null,img_url:null}]}},inject:{enable:!0,css:[null],js:["/js/shawjie_modify.js"]},root:"",version:"4.0.5"},KEEP.language_ago={second:"%s seconds ago",minute:"%s minutes ago",hour:"%s hours ago",day:"%s days ago",week:"%s weeks ago",month:"%s months ago",year:"%s years ago"},KEEP.language_code_block={copy:"Copy code",copied:"Copied",fold:"Fold code block",folded:"Folded"},KEEP.language_copy_copyright={copy:"Copy copyright info",copied:"Copied",title:"Original post title",author:"Original post author",link:"Original post link"}</script><meta name="generator" content="Hexo 7.0.0"></head><body><div class="progress-bar-container"><span class="pjax-progress-bar"></span> <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i></div><main class="page-container border-box"><div class="page-main-content border-box"><div class="page-main-content-top"><header class="header-wrapper"><div class="border-box header-content"><div class="left border-box"><a class="logo-image border-box" href="/"><img src="/images/dear_kana.jpg"> </a><a class="site-name border-box" href="/">Shaw&#39;s Log | 茶歇小栈</a></div><div class="right border-box"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">HOME</a></li><li class="menu-item"><a href="/archives">ARCHIVES</a></li><li class="menu-item"><a href="/tags">TAGS</a></li><li class="menu-item"><a href="/about">ABOUT</a></li><li class="menu-item search search-popup-trigger"><i class="fas search fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">HOME</a></li><li class="drawer-menu-item flex-center"><a href="/archives">ARCHIVES</a></li><li class="drawer-menu-item flex-center"><a href="/tags">TAGS</a></li><li class="drawer-menu-item flex-center"><a href="/about">ABOUT</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle border-box"><div class="main-content border-box"><div class="fade-in-down-animation"><div class="post-page-container border-box"><div class="post-content-container border-box"><div class="post-content-top border-box" style="height:13.8rem"><div class="cover-post-title">Spring Listener 之 喂，在吗？</div><img class="post-cover" src="/images/spring-application-listener/2DMGm1fso6FngZj.png" onerror='this.style.display="none"'></div><div class="post-content-bottom border-box has-cover"><div class="post-header border-box"><div class="avatar-box border-box"><img src="/images/dear_kana.jpg"></div><div class="info-box"><div class="author border-box"><span class="name">ShawJie</span></div><div class="meta-info border-box"><div class="post-meta-info-container border-box post"><div class="post-meta-info border-box"><span class="meta-info-item post-create-date"><i class="icon fa-solid fa-calendar-check"></i>&nbsp; <span class="pc">2021-03-10 23:56:14</span> <span class="mobile">2021-03-10 23:56</span> </span><span class="meta-info-item post-update-date"><i class="icon fa-solid fa-file-pen"></i>&nbsp; <span class="pc" data-updated="Thu Nov 30 2023 10:02:18 GMT+0800">2023-11-30 10:02:18</span> </span><span class="post-tag meta-info-item border-box"><i class="icon fas fa-tags"></i>&nbsp;<ul class="post-tag-ul"><li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/Spring-Framework/">Spring Framework</a></li></ul></span></div></div></div></div></div><div class="post-content keep-markdown-body"><blockquote><p>监听者模式，大家应该已经再熟悉不过了。会计Q和销售员A说：”你那边卖了点儿啥就通知我一声，我这边得记上一笔”，描述很简单，这也就是监听者模式的核心，触发者 + 源事件 + 监听器。Spring在应用内部也对事件监听提供了相关的实现，那么这回我就就来看看Spring的事件组件，聊点…你熟系的陌生的，知道的，不知道的。</p></blockquote><h2 id="先吃个栗子"><a href="#先吃个栗子" class="headerlink" title="先吃个栗子"></a>先吃个栗子</h2><p>​	Java对事件相关的构建进行了一些抽象去规范行为，包括源事件<code>EventObject</code>，监听器类<code>EventListener</code>，而Spring对此进行了实现，所以在内容开始之前，我们得先知道怎么创建一个事件并触发它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义事件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SampleEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object someData;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SampleEvent</span><span class="params">(Object source, Object someData)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件SampleEvent的监听者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SampleListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;SampleEvent&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplication</span><span class="params">(SampleEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// event processing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过Spring的Publisher进行事件触发动作</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ApplicationEventPublisher</span>().publish(<span class="keyword">new</span> <span class="title class_">SampleEvent</span>(getClass(), <span class="string">&quot;data&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	一个标准的事件定义触发流程并不复杂，但是其中监听器的注册逻辑以及在事件触发时Spring是如何找到对应的监听器的呢？别急，跟着我慢慢看，说不定看着的同时，还会收获一些关于<code>Spring ApplicationListener</code>小小的新玩法。</p><p>​	Ps: 这回的内容相对于之前我们聊过的<code>Spring AOP</code>以及<code>Spring Transcation</code>会简单一些，虽然会依赖到一点点<code>AOP</code>相关的逻辑，想了解的同学也可以点<a class="link" target="_blank" rel="noopener" href="https://shawjie.me/2020/12/31/Spring-aop/">这里<i class="fas fa-external-link-alt"></i></a>去看看，这次也不需要依赖某个<code>smoke-test</code>项目。我们可以稍微放松一下，新建一个Spring Boot项目，和我一起慢慢的去理解<code>ApplicationListener</code>的设计逻辑。</p><h2 id="那个发言人呢？"><a href="#那个发言人呢？" class="headerlink" title="那个发言人呢？"></a>那个发言人呢？</h2><p>​	消息实例也好，监听器也罢，中间总得有个玩意把消息发布出来，让监听器能知道事件发生了这才有意义。<code>Spring</code>抽象出了事件发布器<code>ApplicationEventListener</code>并规定了事件发布行为方法<code>publishEvent</code>。我们可以看一下实现了<code>ApplicationEventListener</code>接口的<code>AbstractApplicationContext</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.context.support.AbstractApplicationContext</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">DefaultResourceLoader</span></span><br><span class="line">		<span class="keyword">implements</span> <span class="title class_">ConfigurableApplicationContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">         <span class="comment">// 通过标准ApplicationEvent触发事件</span></span><br><span class="line">		publishEvent(event, <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(Object event)</span> &#123;</span><br><span class="line">         <span class="comment">// 通过任意类型对象触发事件</span></span><br><span class="line">		publishEvent(event, <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(Object event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> &#123;</span><br><span class="line">		Assert.notNull(event, <span class="string">&quot;Event must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">				 <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * 如果消息对象不是标准事件类型 </span></span><br><span class="line"><span class="comment">          * 则需要通过payloadApplicationEvent对象</span></span><br><span class="line"><span class="comment">          * 将其包装为标准事件类型对象</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">		ApplicationEvent applicationEvent;</span><br><span class="line">		<span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEvent) &#123;</span><br><span class="line">			applicationEvent = (ApplicationEvent) event;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			applicationEvent = <span class="keyword">new</span> <span class="title class_">PayloadApplicationEvent</span>&lt;&gt;(<span class="built_in">this</span>, event);</span><br><span class="line">			<span class="keyword">if</span> (eventType == <span class="literal">null</span>) &#123;</span><br><span class="line">				eventType = ((PayloadApplicationEvent&lt;?&gt;) applicationEvent).getResolvableType();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 我们触发事件的主角，ApplicationEventMulticaster</span></span><br><span class="line"><span class="comment">		 * 再Multicaster对象还没初始化之前被触发的事件会先存储在</span></span><br><span class="line"><span class="comment">		 * earlyApplicationEvents集合中，等待广播器初始化后在进行触发</span></span><br><span class="line"><span class="comment">		 */</span> </span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.earlyApplicationEvents != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="built_in">this</span>.earlyApplicationEvents.add(applicationEvent);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 同时若ApplicationContext还有父级上下文，则也会再父级上下文中进行一次事件的触发</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.parent != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">this</span>.parent <span class="keyword">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class="line">				((AbstractApplicationContext) <span class="built_in">this</span>.parent).publishEvent(event, eventType);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">this</span>.parent.publishEvent(event);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="找到一个大喇叭"><a href="#找到一个大喇叭" class="headerlink" title="找到一个大喇叭"></a>找到一个大喇叭</h3><p>​	从<code>AbstractApplicationContext</code>中触发事件的逻辑可以知道触发的核心是<code>ApplicationEventMulticaster</code>，那这个对象是哪来的呢？这就得复习一下我们Spring应用启动的<code>refresh</code>方法了。在完成<code>SpringBean</code>扫描之后会通过<code>initApplicationEventMulticaster</code>方法进行广播器的初始化动作，我们可以看一下它的初始化逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initApplicationEventMulticaster</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 确定目前IoC容器内是否已经存在beanName为applicationEventMulticaster的广播器对象</span></span><br><span class="line"><span class="comment">     * 若不存在，则进行默认初始化操作，反之，则会将存在的广播器配置进上下文</span></span><br><span class="line"><span class="comment">     * 依据这部分逻辑 我们可以自定义自己的广播器 </span></span><br><span class="line"><span class="comment">     * 为什么需要自定义？ 我们先稍一稍 过会儿再说</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationEventMulticaster =</span><br><span class="line">            beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationEventMulticaster = <span class="keyword">new</span> <span class="title class_">SimpleApplicationEventMulticaster</span>(beanFactory);</span><br><span class="line">        beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="built_in">this</span>.applicationEventMulticaster);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>​	由于我们应用中的上下文<code>AnnotationConfigApplicationContext(标准Spring应用上下文对象)</code>或是<code>AnnotationConfigServletWebServerApplicationContext(应用上下文对象)</code>，都基于<code>AbstractApplicationContext</code>进行实现，因此我们也可以直接使用<code>ApplcationContext</code>对象进行消息的发布。换句话说，在需要进行消息推送的时候我们既可以通过自动注入的<code>ApplicationEventPublisher</code>对象进行消息发布，也可以直接通过<code>ApplicationContext</code>对象进行消息发布，毕竟从核心来说，两者是同一个对象。</p><p>​	我们可以通过一个简单的注入证明这一点。但是以语义的方面来看，还是建议使用<code>ApplicationEventPublisher</code>进行消息发布。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SampleApplication</span> <span class="keyword">implements</span> <span class="title class_">ApplicationRunner</span>, ApplicationContextAware, ApplicationEventPublisherAware &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SampleApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher eventPublisher;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 通过ApplicationContextAware接口注入ApplicationContext对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 通过ApplicationEventPublisherAware接口注入ApplicationEventPublisher对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher eventPublisher)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.eventPublisher = eventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 结果为true</span></span><br><span class="line">        Assert.isTrue(<span class="built_in">this</span>.applicationContext == <span class="built_in">this</span>.eventPublisher, <span class="string">&quot;not equals&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发言人有了，听众也得有"><a href="#发言人有了，听众也得有" class="headerlink" title="发言人有了，听众也得有"></a>发言人有了，听众也得有</h2><blockquote><p>作为Spring的应用组件，当然也与<code>IoC</code>容器脱离不开干系，我们需要把我们的监听器注册为Bean交付予<code>IoC</code>容器托管。但是只是单纯的注册为Bean自然是不够的，我们还需要把监听器添加进事件发布器也就是我们的应用上下文中，以在有消息发生时知道有哪些候选监听器。</p></blockquote><p>Spring的监听器定义有两种方式：</p><ul><li>类实现<code>ApplicationListener</code>接口，并标记为<code>SpringBean</code>声明为监听器</li><li>在被标记为<code>SpringBean</code>的类上，通过对方法标记<code>@EventListener</code>注解声明为监听器</li></ul><p>两种声明方式当然也对应着两种扫描时机和注册时机，我们一个一个来看。</p><h3 id="标准的监听器"><a href="#标准的监听器" class="headerlink" title="标准的监听器"></a>标准的监听器</h3><p>​	标准模式的监听器我们可以通过实现接口进行定义，譬如通过实现<code>ApplicationListener</code>接口定义一个标准的监听器，或实现<code>SmartApplicationListener</code>接口去根据事件类型和事件源进行事件处理，或实现<code>GenericApplicationListener</code>接口根据消息对象类型（不再局限于事件类型）和消息源进行事件的处理。感兴趣的同学也可以去上面这些接口看看接口可以实现的行为。</p><p>​	在我们完成一个标准监听器定义并将其标记为<code>SpringBean</code>之后，Spring在启动时会扫描将其装载进<code>IoC</code>容器，这时候…如果你是<code>Spring Listener</code>的责任开发，你会通过什么方式把监听器塞进应用上下文的监听器列表中。</p><p>​	要是我的话，可能会通过这两种方式实现装载：</p><ul><li>通过定义一个<code>BeanPostProcessor</code>对监听器相关的<code>SpringBean</code>进行处理并将其装载到应用上下文中<ul><li>这样实现需要注意要在其它<code>BeanPostProcessor</code>完成bean后处理逻辑处理&#x2F;增强完后再进行装载操作，保证装载的bean已经是后处理的终态</li></ul></li><li>在所有Bean初始化完成之后，通过Spring的回调（实现<code>SmartInitializingSingleton</code>，<code>InitializingBean</code>等回调接口类），并注入<code>BeanFactory</code>，在<code>beanFactory</code>中扫描符合条件的监听器类，进行处理并将其装载到应用上下文中</li></ul><p>​	Spring对标准的监听器装配采用了第一种方法，至于第二种方法，咱们先撂一撂过会再说。在Spring的应用启动方法<code>refresh()</code>中，有这么一个方法调用，<code>registerBeanPostProcessors(beanFactory)</code>，该方法会扫描应用内的<code>beanPostProcessor</code>并将其配置进<code>BeanFactory</code>，我们看一下里面的大体逻辑（我会删掉一些与本文不太重要的逻辑内容）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.context.support.PostProcessorRegistrationDelegate#registerBeanPostProcessors</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBeanPostProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">			ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从beanFactory中择出所有beanPostProcessor</span></span><br><span class="line">    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 扫描/处理 根据优先级将应用内的后处理器配置进BeanFactory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在最后将ApplicationListenerDetector后处理器配置进beanFactory中</span></span><br><span class="line"><span class="comment">     * 配置在后处理器序列末尾保证监听器在被添加进应用上下文时已经完成了所有必要的处理（譬如Async方法增强）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationListenerDetector</span>(applicationContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	诶嘿嘿，好像被忽略掉的方法内容有点多，但是不打紧，我们找到了我们装配标准监听器的主角<code>ApplicationListenerDetector</code>。其会在所有后处理其都处理完成之后，通过<code>beanPostProcessor</code>的钩子方法<code>postProcessAfterInitialization</code>将监听器装载进上下文，我们可以看看它的具体逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.context.support.ApplicationListenerDetector#postProcessAfterInitialization</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line">    <span class="comment">// 确定当前bean是监听器实例</span></span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationListener) &#123;</span><br><span class="line">        <span class="comment">// 判断当前bean的模式是单例的</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonNames.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (Boolean.TRUE.equals(flag)) &#123;</span><br><span class="line">            <span class="comment">// 将bean装配进应用上下文中</span></span><br><span class="line">            <span class="built_in">this</span>.applicationContext.addApplicationListener((ApplicationListener&lt;?&gt;) bean);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Boolean.FALSE.equals(flag)) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 若监听器模式非单例，因为无法通过事件传播达到多播目的</span></span><br><span class="line"><span class="comment">             * 因此无法作为监听器被添加进上下文中</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">this</span>.singletonNames.remove(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不需要对bean本身做任何处理 直接返回</span></span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	从以上逻辑我们大致能获取到两个信息：</p><ol><li><code>ApplicationListenerDetector</code>只能装载类实例为<code>ApplicationListener</code>的bean，不会处理通过<code>@EventListener</code>注解标记的方法模式的监听器</li><li>非单例<code>SpringBean</code>无法作为监听器被配置进应用上下文中</li></ol><p>那么既然<code>ApplicationListenerDetector</code>无法处理<code>@EventListener</code>注解，那这部分注解模式的监听器又是如何被添加进应用上下文的呢？不急，下面就说它了。</p><h3 id="EventListener标注的监听器"><a href="#EventListener标注的监听器" class="headerlink" title="@EventListener标注的监听器"></a><code>@EventListener</code>标注的监听器</h3><p>​	关于通过<code>@EventListener</code>注解进行标记监听器的装配方式，诶，那咱么就得回头看看我们应用上下文<code>ApplicationContext</code>在初始化的时候都做了些什么了。</p><p>​	我们都知道<code>SpringBoot</code>应用在启动时会根据类路径中是否存在<code>WebFlux</code>或者<code>Servlet</code>相关类对象进行应用的类型推断（不知道的你现在知道了ヽ(✿ﾟ▽ﾟ)ノ），并根据应用类型选择对应的上下文进行初始化，但是无论是哪种上下文，在构造函数内都会创建一个<code>AnnotatedBeanDefinitionReader</code>的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AnnotationConfigServletWebServerApplicationContext#&lt;init&gt;()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigServletWebServerApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">AnnotatedBeanDefinitionReader</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.scanner = <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	而在<code>AnnotatedBeanDefinitionReader</code>的初始化过程中，会通过<code>AnnotationConfigUtils#registerAnnotationConfigProcessors</code>方法向我们的<code>IoC</code>容器中注册一些对象，而我们要关注扫描装配类也就在这里。让我们来看看其向<code>IoC</code>容器中注册bean的逻辑（我还是会忽略掉一些与本文关系不大代码）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">registerAnnotationConfigProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">    BeanDefinitionRegistry registry, <span class="meta">@Nullable</span> Object source)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包装BeanDefinitionRegistry</span></span><br><span class="line">    <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> unwrapDefaultListableBeanFactory(registry);</span><br><span class="line">    <span class="keyword">if</span> (beanFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getDependencyComparator() <span class="keyword">instanceof</span> AnnotationAwareOrderComparator)) &#123;</span><br><span class="line">            <span class="comment">// 配置beanFactory的依赖比较器</span></span><br><span class="line">            beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getAutowireCandidateResolver() <span class="keyword">instanceof</span> ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class="line">            <span class="comment">// 配置beanFactory的自动装配候选解析器</span></span><br><span class="line">            beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 中间注册了一些其它的Bean，包括JSR支持类，JPA支持类，Configuration配置类后处理器等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当IoC容器中不存在eventListenerProcessor时</span></span><br><span class="line"><span class="comment">     * 向容器内注册类型为EventListenerMethodProcessor的监听器方法处理器</span></span><br><span class="line"><span class="comment">     * 也就是我们所寻找的处理@EventListener注解的玩意</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(EventListenerMethodProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当IoC容器内不存在eventListenerFactory时</span></span><br><span class="line"><span class="comment">     * 向容器内注册类型为DefaultEventListenerFactory的监听器包装工厂类</span></span><br><span class="line"><span class="comment">     * 它用于把标记了@EventListener注解的方法包装成标准的监听器类对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(DefaultEventListenerFactory.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> beanDefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	监听器方法处理器<code>EventListenerMethodProcessor</code>，实现了<code>BeanFactoryAware</code>接口和<code>SmartInitializingSingleton</code>接口，前者用于获取<code>beanFactory</code>对象，后者用于通过Spring的钩子回调对<code>IoC</code>容器中的bean进行扫描，并将标记了<code>@EventListener</code>的方法通过<code>eventListenerFactory</code>封装为监听器包装类并添加进应用上下文中。这段描述是不是有点耳熟，没错….在标准监听器小节中提到的第二种监听器装配方式，就是给注解模式的监听器所使用的。我们可以具体看看它的扫描装配逻辑，可能有点点长。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化后钩子方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterSingletonsInstantiated</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取IoC容器对象BeanFactory</span></span><br><span class="line">    <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="built_in">this</span>.beanFactory;</span><br><span class="line">    <span class="comment">// 从容器中捞出所有的Bean</span></span><br><span class="line">    String[] beanNames = beanFactory.getBeanNamesForType(Object.class);</span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 获取Bean目标类型逻辑...</span></span><br><span class="line"><span class="comment">         * 若获取成功 则进入bean的判断处理阶段</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        processBean(beanName, type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Class&lt;?&gt; targetType)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 由于一个类可以创建多个实例并添加进Spring</span></span><br><span class="line"><span class="comment">     * 所以当类上不存在标记@EventListener方法时会被缓存进set</span></span><br><span class="line"><span class="comment">     * 若后续有相同类进入 可减少筛选工作量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.nonAnnotatedClasses.contains(targetType) &amp;&amp;</span><br><span class="line">        <span class="comment">// 判断目标类是否付和存在EventListener注解的条件</span></span><br><span class="line">        AnnotationUtils.isCandidateClass(targetType, EventListener.class) &amp;&amp;</span><br><span class="line">        <span class="comment">// 判断目标类不是Spring的内部类</span></span><br><span class="line">        !isSpringContainerClass(targetType)) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Method, EventListener&gt; annotatedMethods = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 在目标类上查找标记了@EventListener注解的方法</span></span><br><span class="line">            annotatedMethods = </span><br><span class="line">                MethodIntrospector.selectMethods(</span><br><span class="line">                	targetType, </span><br><span class="line">                	(MethodIntrospector.MetadataLookup&lt;EventListener&gt;) method -&gt; AnnotatedElementUtils</span><br><span class="line">                		.findMergedAnnotation(method, EventListener.class)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">// 类方法无法解析异常</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有找到目标方法，则将目标类塞进无注解缓存</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(annotatedMethods)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.nonAnnotatedClasses.add(targetType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取应用上下文对象</span></span><br><span class="line">            <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationContext;</span><br><span class="line">            <span class="comment">// 获取监听器包装工厂类</span></span><br><span class="line">            List&lt;EventListenerFactory&gt; factories = <span class="built_in">this</span>.eventListenerFactories;</span><br><span class="line">            <span class="keyword">for</span> (Method method : annotatedMethods.keySet()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (EventListenerFactory factory : factories) &#123;</span><br><span class="line">                    <span class="comment">// 判断工厂是否支持处理当前方法(默认为true)</span></span><br><span class="line">                    <span class="keyword">if</span> (factory.supportsMethod(method)) &#123;</span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * 获取可调用方法的实例</span></span><br><span class="line"><span class="comment">                         * 由于此时目标类实例已经完成增强逻辑 因此获取到的方法实例也是增强后的方法实例</span></span><br><span class="line"><span class="comment">                         * 即方法调用时包含增强的业务逻辑 譬如标记@Async的异步方法逻辑</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="type">Method</span> <span class="variable">methodToUse</span> <span class="operator">=</span> AopUtils.selectInvocableMethod(method, context.getType(beanName));</span><br><span class="line">                        <span class="comment">// 通过工厂类将方法包装为标准监听器格式</span></span><br><span class="line">                        ApplicationListener&lt;?&gt; applicationListener =</span><br><span class="line">                            factory.createApplicationListener(beanName, targetType, methodToUse);</span><br><span class="line">                        <span class="keyword">if</span> (applicationListener <span class="keyword">instanceof</span> ApplicationListenerMethodAdapter) &#123;</span><br><span class="line">                            ((ApplicationListenerMethodAdapter) applicationListener).init(context, <span class="built_in">this</span>.evaluator);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 将包装后的监听器添加进应用上下文中</span></span><br><span class="line">                        context.addApplicationListener(applicationListener);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	至此，我们所定义的两种模式的监听器，都被顺利的装在进了应用上下文中。那么万事俱备，现在就拿起我们前边儿准备好的大喇叭喊一嗓子（指发布事件），看看后续的故事又是怎么发展的吧。</p><h4 id="Tips-2"><a href="#Tips-2" class="headerlink" title="Tips - 2"></a>Tips - 2</h4><p>​	默认的监听器包装工厂类会将<code>@EventListener</code>标注的方法封装进<code>ApplicationListenerMethodAdapter</code>对象中，而包装类在构造时会解析监听器方法的其它属性，包括<code>@Order</code>、<code>@EventListener(condition)</code>，在事件触发时通过调用<code>method.invoke(args)</code>方法进行本身方法的调用。标准的监听器方法返回值是<code>Void</code>，但通过注解标注的监听器方法可以拥有返回值，我们可看一下包装类对方法返回值的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ApplicationListenerMethodAdapter#handleResult</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleResult</span><span class="params">(Object result)</span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 若方法返回值为CompletionStage实例</span></span><br><span class="line"><span class="comment">	 * 如: CompleteFuture，则会在其执行完之后处理其结果</span></span><br><span class="line"><span class="comment">	 * 若结果不为空 则会作为一个的事件进行发布</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">if</span> (result <span class="keyword">instanceof</span> CompletionStage) &#123;</span><br><span class="line">        ((CompletionStage&lt;?&gt;) result).whenComplete((event, ex) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (ex != <span class="literal">null</span>) &#123;</span><br><span class="line">                handleAsyncError(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (event != <span class="literal">null</span>) &#123;</span><br><span class="line">                publishEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (result <span class="keyword">instanceof</span> ListenableFuture) &#123;</span><br><span class="line">        <span class="comment">// 逻辑同CompletionStage，若返回值不为空则作为新事件发布</span></span><br><span class="line">        ((ListenableFuture&lt;?&gt;) result).addCallback(<span class="built_in">this</span>::publishEvents, <span class="built_in">this</span>::handleAsyncError);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 直接进行事件发布</span></span><br><span class="line">        publishEvents(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 由于会将返回值作为新的事件进行发布</span></span><br><span class="line"><span class="comment">     * 若返回值类型和方法接收的事件类型一致会出现无限循环的情况</span></span><br><span class="line"><span class="comment">     * 这点需要格外注意</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	我们可以通过这个特性完成一些异步的操作，如通过事件A触发监听器A进行逻辑处理，监听器A完成逻辑处理后可以返回事件B，让监听器B进行后续操作，完成一个事件驱动的逻辑设计。</p><h2 id="发布事件-喊一嗓子"><a href="#发布事件-喊一嗓子" class="headerlink" title="发布事件 - 喊一嗓子"></a>发布事件 - 喊一嗓子</h2><p>​	监听器和广播器已经全部准备好了，上下文中<code>publishEvent</code>逻辑我们在找广播器的阶段也已经看过了，那么现在剩下的…就是在一个事件被发布时，要如何找到对应的监听该事件的监听器呢？我们直接进入到<code>ApplicationEvnetMulticaster</code>的<code>multicastEvent</code>方法，看看发布事件时的实际操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimpleApplicationEventMulticaster#multicastEvent</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 标准事件类型按照默认逻辑流通 但若发布的事件非标准事件类型</span></span><br><span class="line"><span class="comment"> * 如Integer 则会在上层被封装进PayloadApplicationEvent进行后续流程处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> &#123;</span><br><span class="line">  <span class="comment">// 获取事件类型</span></span><br><span class="line">  <span class="type">ResolvableType</span> <span class="variable">type</span> <span class="operator">=</span> (eventType != <span class="literal">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">  <span class="comment">// 获取任务执行器</span></span><br><span class="line">  <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> getTaskExecutor();</span><br><span class="line">  <span class="comment">// 通过getApplicationListeners获取匹配的监听器</span></span><br><span class="line">  <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 若任务执行器存在，则通过执行器异步执行事件处理逻辑</span></span><br><span class="line"><span class="comment">     * 反之则以串行的方式进行事件逻辑处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (executor != <span class="literal">null</span>) &#123;</span><br><span class="line">      executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      invokeListener(listener, event);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	在这里阿肖要插一段，在实际开发过程中主流程在完成一些业务逻辑后发布了事件，而隐藏在事件广播器身后的监听器对于主流程是不可知的，若此时事件广播器的执行流程是串行的，那么监听器的处理逻辑要是稍有纰漏抛出异常，就会导致主流程原本的逻辑无法继续进行，这当然不是我们所期望的，所以在进行事件驱动逻辑开发的时候，一定要做好异常的捕获处理，保证主流程的正常流转。</p><p>​	当然，我们可也以用一些别的小手段，还记得我们在找事件广播器<code>ApplicationEventMulticaster</code>的时候提到过我们可以自定义广播器么，根据广播器初始化逻辑，会在<code>IoC</code>容器中查找bean名称为<code>applicationEventMulticaster</code>的bean，若bean不存在，则进行初始化，反之则会使用已存在的广播器。我们可以利用这部分逻辑定义我们自己的广播器并在配置类中注册为bean，<code>SimpleApplicationEventMilticaster</code>的类上有两个字段<code>taskExecutor</code>和<code>errorHandler</code>，在注册时我们可以配置上时间的异步任务执行器和通用异常处理器，类似这样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MulticasterConfiguration</span> &#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> ApplicationEventMulticaster <span class="title function_">applicationEventMulticaster</span><span class="params">(BeanFactory beanFactory)</span> &#123;</span><br><span class="line">		<span class="type">SimpleApplicationEventMulticaster</span> <span class="variable">multicaster</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleApplicationEventMulticaster</span>(beanFactory);</span><br><span class="line">    	<span class="comment">// 设置任务线程池（实际开发场景建议根据配置线程池）</span></span><br><span class="line">		multicaster.setTaskExecutor(Executors.newSingleThreadExecutor());</span><br><span class="line">   		<span class="comment">// 配置通用的任务异常处理逻辑</span></span><br><span class="line">		multicaster.setErrorHandler((ex) -&gt; &#123;</span><br><span class="line">			logger.warn(<span class="string">&quot;has something error occur&quot;</span>, ex);</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">return</span> multicaster;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	通过事件监听器逻辑的异步执行，我们能保证监听器逻辑不会影响主流程的继续进行。但是由于广播器所配置的任务执行器是固定的，若是线程池的配置不当，可能会导致线程池任务溢出。其次会导致有前后依赖的监听器逻辑执行有误（譬如事件A有两个监听器，监听器2号的执行逻辑需要监听器1号执行完成，异步执行无法保证完成后再执行2号监听器逻辑）。所以我们也可以通过对监听器方法标记<code>@Async</code>注解实现方法的异步执行，同时可以指明使用的线程池，避免所有事件监听器依赖同一个线程池的问题。当然两种方式各有利弊，还是根据实际的业务开发场景细细斟酌会更好一点。</p><p>​	回到我们事件发布的逻辑上，广播器通过<code>getApplicationListeners</code>方法获取与之匹配的监听器列表，我们一起来看看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractApplicationEventMulticaster#getApplicationListeners</span></span><br><span class="line"><span class="keyword">protected</span> Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners(</span><br><span class="line">			ApplicationEvent event, ResolvableType eventType) &#123;</span><br><span class="line">	<span class="comment">// 获取event的source字段 用于SmartApplicationListener的源匹配逻辑</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">source</span> <span class="operator">=</span> event.getSource();</span><br><span class="line">    Class&lt;?&gt; sourceType = (source != <span class="literal">null</span> ? source.getClass() : <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 构建以事件类型 + 源类型的缓存</span></span><br><span class="line">    <span class="type">ListenerCacheKey</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListenerCacheKey</span>(eventType, sourceType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 由于ListenerCacheKey重写了equals和hashcode方法</span></span><br><span class="line"><span class="comment">   * 所以可以直接以对象作为缓存的Key</span></span><br><span class="line"><span class="comment">   * 若能通过key获取到ListenerRetriever对象</span></span><br><span class="line"><span class="comment">   * 说明之前已经处理过相同的事件类型和事件源 直接从缓存拉取监听器列表就行</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="type">ListenerRetriever</span> <span class="variable">retriever</span> <span class="operator">=</span> <span class="built_in">this</span>.retrieverCache.get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (retriever != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> retriever.getApplicationListeners();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁保证添加缓存的操作是串行执行的</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.retrievalMutex) &#123;</span><br><span class="line">        <span class="comment">// 双重检查保证缓存还没有被添加</span></span><br><span class="line">        retriever = <span class="built_in">this</span>.retrieverCache.get(cacheKey);</span><br><span class="line">        <span class="keyword">if</span> (retriever != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> retriever.getApplicationListeners();</span><br><span class="line">        &#125;</span><br><span class="line">        retriever = <span class="keyword">new</span> <span class="title class_">ListenerRetriever</span>(<span class="literal">true</span>);</span><br><span class="line">        Collection&lt;ApplicationListener&lt;?&gt;&gt; listeners =</span><br><span class="line">            <span class="comment">// 从监听器列表中筛选出目标监听器</span></span><br><span class="line">            retrieveApplicationListeners(eventType, sourceType, retriever);</span><br><span class="line">        <span class="comment">// 将目标监听器列表进行缓存</span></span><br><span class="line">        <span class="built_in">this</span>.retrieverCache.put(cacheKey, retriever);</span><br><span class="line">        <span class="keyword">return</span> listeners;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	在事件触发时，广播器会根据<code>EventType + Source</code>在监听器列表里查找符合条件的监听器并将其缓存起来。实现<code>SmartApplicationListener</code>接口或<code>GenericApplicationListener</code>接口的监听器可以通过<code>supportsEventType</code>方法和<code>supportsSourceType</code>方法支持多种事件类型，虽匹配类型可以根据逻辑动态变动，但若在第一次事件触发时没有成功匹配，则不会有第二次匹配机会，监听器也不会按期望被加入监听器列表中。</p><p>​	在<code>retrieveApplicationListeners</code>方法中，会取出所有的<code>ApplicationListener</code>实例，并通过<code>supportsEvent</code>方法判断是是否是事件的目标监听器，在找齐了监听器之后，会根据<code>Order</code>配置对监听器进行排序，并循环调用各个监听器的<code>onApplication</code>方法触发事件处理逻辑。由于<code>retrieveApplicationListeners</code>方法整体逻辑较多，我们就单独把判断类型支持的<code>supportsEvent</code>方法择出来看看，想知道方法整体逻辑的同学也可以线性的看一看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractApplicationEventMulticaster#supportsEvent</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">supportsEvent</span><span class="params">(</span></span><br><span class="line"><span class="params">    ApplicationListener&lt;?&gt; listener, ResolvableType eventType, <span class="meta">@Nullable</span> Class&lt;?&gt; sourceType)</span> &#123;</span><br><span class="line">	<span class="comment">// 于此会对普通的ApplicationListener包装为GenericApplicationListener便于之后的类型检测</span></span><br><span class="line">    <span class="type">GenericApplicationListener</span> <span class="variable">smartListener</span> <span class="operator">=</span> </span><br><span class="line">        (listener <span class="keyword">instanceof</span> GenericApplicationListener ? </span><br><span class="line">         (GenericApplicationListener) listener : <span class="keyword">new</span> <span class="title class_">GenericApplicationListenerAdapter</span>(listener));</span><br><span class="line">    <span class="keyword">return</span> (smartListener.supportsEventType(eventType) &amp;&amp; smartListener.supportsSourceType(sourceType));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsEventType</span><span class="params">(ResolvableType eventType)</span> &#123;</span><br><span class="line">    <span class="comment">// 若监听器是SmartApplicationListener 则交予其自身对类型进行支持判定</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.delegate <span class="keyword">instanceof</span> SmartApplicationListener) &#123;</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span>&gt; eventClass = (Class&lt;? <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span>&gt;) eventType.resolve();</span><br><span class="line">        <span class="keyword">return</span> (eventClass != <span class="literal">null</span> &amp;&amp; ((SmartApplicationListener) <span class="built_in">this</span>.delegate).supportsEventType(eventClass));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 确定触发的事件类型可以被监听器所支持</span></span><br><span class="line"><span class="comment">         * 即 父类监听器可以监听子类事件</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span>.declaredEventType == <span class="literal">null</span> || <span class="built_in">this</span>.declaredEventType.isAssignableFrom(eventType));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>​	至此，我们找到了广播器，找到了监听器，然后把他们组合在了一起，好好的利用它们能极大的解除系统内逻辑的耦合，使系统可扩展性和可维护性大大提升。我们开发过程中引入的Mq中间件也是在分布式应用的情况下实现了这些模式，只不过中间件所要考虑的问题就会偏向于RPC、消息丢失、持久化等逻辑。<code>Spring Listener</code>组件的整体架构用到了很多设计模式，监听器模式（根本），装饰模式（各处的Adapter），代理模式（<code>Cglib</code>的类增强）等等…</p><p>​	还是那句话，Spring是个大家伙，我也不知道什么时候能把它啃完，但是其中很多的组件开发思路也值得我们参考，譬如<code>@EventListener</code>标记方法的的扫描装配方法，我们也可以用这个思路在项目里实现一些自己的组件。</p><h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>​	整篇内容从开始准备到写到这里，总共花了十天的时间，本来以为<code>Spring Listener</code>的内容会比较简单，没想到发散开写也有这么多，不管终归还是写完了。有点点累，但是也鼓励鼓励坚持到现在的自己，下一篇要写什么还没有想好，所有大家伙有什么想看的也可以告诉我，这样我就不用自己想选题了诶嘿嘿，歇一歇也要把20年的年终总结和21年的计划写了。总之…谢谢你能看到这里。</p></div><div class="post-bottom-tags-and-share border-box"><div><ul class="post-tags-box border-box"><li class="tag-item border-box"><i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/Spring-Framework/">Spring Framework</a></li></ul></div><div></div></div><div class="post-nav border-box"><div class="prev-post"><a class="prev" rel="prev" href="/2021/04/24/spring-dev-tools/" title="Spring DevTools 之 你总是喜新厌旧"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item text-ellipsis">Spring DevTools 之 你总是喜新厌旧</span> <span class="post-nav-item">Prev posts</span></span></a></div><div class="next-post"><a class="next" rel="next" href="/2021/02/06/spring-transaction/" title="Spring Transaction 之 不离不弃生死相依"><span class="title flex-center"><span class="post-nav-title-item text-ellipsis">Spring Transaction 之 不离不弃生死相依</span> <span class="post-nav-item">Next posts</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div></div></div><div class="pc-post-toc right-toc"><div class="post-toc-wrap border-box"><div class="post-toc border-box"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%88%E5%90%83%E4%B8%AA%E6%A0%97%E5%AD%90"><span class="nav-text">先吃个栗子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%82%A3%E4%B8%AA%E5%8F%91%E8%A8%80%E4%BA%BA%E5%91%A2%EF%BC%9F"><span class="nav-text">那个发言人呢？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E5%A4%A7%E5%96%87%E5%8F%AD"><span class="nav-text">找到一个大喇叭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tips"><span class="nav-text">Tips</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%91%E8%A8%80%E4%BA%BA%E6%9C%89%E4%BA%86%EF%BC%8C%E5%90%AC%E4%BC%97%E4%B9%9F%E5%BE%97%E6%9C%89"><span class="nav-text">发言人有了，听众也得有</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E7%9A%84%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-text">标准的监听器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EventListener%E6%A0%87%E6%B3%A8%E7%9A%84%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-text">@EventListener标注的监听器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Tips-2"><span class="nav-text">Tips - 2</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%91%E5%B8%83%E4%BA%8B%E4%BB%B6-%E5%96%8A%E4%B8%80%E5%97%93%E5%AD%90"><span class="nav-text">发布事件 - 喊一嗓子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%BE%E5%B7%B4"><span class="nav-text">尾巴</span></a></li></ol></div></div></div></div></div></div></div><div class="page-main-content-bottom border-box"><footer class="footer border-box"><div class="border-box website-info-box default"><div class="copyright-info info-item default">&copy;&nbsp;<span>2019</span>&nbsp;-&nbsp;2023 &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">ShawJie</a></div><div class="theme-info info-item default">Powered by&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;&&nbsp;Theme&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a></div><div class="icp-info info-item default"><a target="_blank" href="https://beian.miit.gov.cn">浙ICP备20000303号-1</a></div><div class="count-item info-item default"></div></div></footer></div></div><div class="post-tools right-toc"><div class="post-tools-container border-box"><ul class="tools-list border-box"><li class="tools-item flex-center toggle-show-toc"><i class="fas fa-list"></i></li></ul></div></div><div class="side-tools"><div class="side-tools-container border-box"><ul class="side-tools-list side-tools-show-handle border-box"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-toggle-theme-mode flex-center"><i class="fas fa-moon"></i></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list border-box"><li class="tools-item toggle-show-toc-tablet flex-center"><i class="fas fa-list"></i></li><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center show-arrow"><i class="arrow fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="zoom-in-image-mask"><img class="zoom-in-image"></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input"></div><span class="close-popup-btn"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div><div class="tablet-post-toc-mask"><div class="tablet-post-toc"><div class="post-toc-wrap border-box"><div class="post-toc border-box"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%88%E5%90%83%E4%B8%AA%E6%A0%97%E5%AD%90"><span class="nav-text">先吃个栗子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%82%A3%E4%B8%AA%E5%8F%91%E8%A8%80%E4%BA%BA%E5%91%A2%EF%BC%9F"><span class="nav-text">那个发言人呢？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E5%A4%A7%E5%96%87%E5%8F%AD"><span class="nav-text">找到一个大喇叭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tips"><span class="nav-text">Tips</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%91%E8%A8%80%E4%BA%BA%E6%9C%89%E4%BA%86%EF%BC%8C%E5%90%AC%E4%BC%97%E4%B9%9F%E5%BE%97%E6%9C%89"><span class="nav-text">发言人有了，听众也得有</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E7%9A%84%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-text">标准的监听器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EventListener%E6%A0%87%E6%B3%A8%E7%9A%84%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-text">@EventListener标注的监听器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Tips-2"><span class="nav-text">Tips - 2</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%91%E5%B8%83%E4%BA%8B%E4%BB%B6-%E5%96%8A%E4%B8%80%E5%97%93%E5%AD%90"><span class="nav-text">发布事件 - 喊一嗓子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%BE%E5%B7%B4"><span class="nav-text">尾巴</span></a></li></ol></div></div></div></div></main><script src="/js/utils.js"></script><script src="/js/header-shrink.js"></script><script src="/js/back2top.js"></script><script src="/js/toggle-theme.js"></script><script src="/js/code-block.js"></script><script src="/js/main.js"></script><script src="/js/libs/anime.min.js"></script><script src="/js/local-search.js"></script><script src="/js/lazyload.js"></script><div class="pjax"><script src="/js/post/post-helper.js"></script><script src="/js/post/toc.js"></script></div><script src="//cdn.jsdelivr.net/npm/mermaid@10.5.0/dist/mermaid.min.js"></script><script data-pjax>window.mermaid&&mermaid.init()</script><script src="/js/libs/pjax.min.js"></script><script>window.addEventListener("DOMContentLoaded",()=>{window.pjax=new Pjax({selectors:["head title",".page-container",".pjax"],history:!0,debug:!1,cacheBust:!1,timeout:0,analytics:!1,currentUrlFullReload:!1,scrollRestoration:!1}),document.addEventListener("pjax:send",()=>{KEEP.utils.pjaxProgressBarStart()}),document.addEventListener("pjax:complete",()=>{KEEP.utils.pjaxProgressBarEnd(),window.pjax.executeScripts(document.querySelectorAll("script[data-pjax], .pjax script")),KEEP.initExecute()})})</script><script class="custom-inject-js" src="/js/shawjie_modify.js" data-pjax></script></body></html>